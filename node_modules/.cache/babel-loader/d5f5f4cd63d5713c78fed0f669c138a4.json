{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/carlvlewis/floodsight/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LANGUAGE = undefined;\nexports.getDefinitionQueryResultForNamedType = getDefinitionQueryResultForNamedType;\nexports.getDefinitionQueryResultForFragmentSpread = getDefinitionQueryResultForFragmentSpread;\nexports.getDefinitionQueryResultForDefinitionNode = getDefinitionQueryResultForDefinitionNode;\n\nvar _graphqlLanguageServiceUtils = require('graphql-language-service-utils');\n\nvar _assert = require('assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n\nvar LANGUAGE = exports.LANGUAGE = 'GraphQL';\n\nfunction getRange(text, node) {\n  var location = node.loc;\n  (0, _assert2.default)(location, 'Expected ASTNode to have a location.');\n  return (0, _graphqlLanguageServiceUtils.locToRange)(text, location);\n}\n\nfunction getPosition(text, node) {\n  var location = node.loc;\n  (0, _assert2.default)(location, 'Expected ASTNode to have a location.');\n  return (0, _graphqlLanguageServiceUtils.offsetToPosition)(text, location.start);\n}\n\nfunction getDefinitionQueryResultForNamedType(text, node, dependencies) {\n  var name, defNodes, definitions;\n  return _regeneratorRuntime.async(function getDefinitionQueryResultForNamedType$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          name = node.name.value;\n          defNodes = dependencies.filter(function (_ref) {\n            var definition = _ref.definition;\n            return definition.name && definition.name.value === name;\n          });\n\n          if (!(defNodes.length === 0)) {\n            _context.next = 5;\n            break;\n          }\n\n          process.stderr.write('Definition not found for GraphQL type ' + name);\n          return _context.abrupt('return', {\n            queryRange: [],\n            definitions: []\n          });\n\n        case 5:\n          definitions = defNodes.map(function (_ref2) {\n            var filePath = _ref2.filePath,\n                content = _ref2.content,\n                definition = _ref2.definition;\n            return getDefinitionForNodeDefinition(filePath || '', content, definition);\n          });\n          return _context.abrupt('return', {\n            definitions: definitions,\n            queryRange: definitions.map(function (_) {\n              return getRange(text, node);\n            })\n          });\n\n        case 7:\n        case 'end':\n          return _context.stop();\n      }\n    }\n  }, null, this);\n}\n\nfunction getDefinitionQueryResultForFragmentSpread(text, fragment, dependencies) {\n  var name, defNodes, definitions;\n  return _regeneratorRuntime.async(function getDefinitionQueryResultForFragmentSpread$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          name = fragment.name.value;\n          defNodes = dependencies.filter(function (_ref3) {\n            var definition = _ref3.definition;\n            return definition.name.value === name;\n          });\n\n          if (!(defNodes.length === 0)) {\n            _context2.next = 5;\n            break;\n          }\n\n          process.stderr.write('Definition not found for GraphQL fragment ' + name);\n          return _context2.abrupt('return', {\n            queryRange: [],\n            definitions: []\n          });\n\n        case 5:\n          definitions = defNodes.map(function (_ref4) {\n            var filePath = _ref4.filePath,\n                content = _ref4.content,\n                definition = _ref4.definition;\n            return getDefinitionForFragmentDefinition(filePath || '', content, definition);\n          });\n          return _context2.abrupt('return', {\n            definitions: definitions,\n            queryRange: definitions.map(function (_) {\n              return getRange(text, fragment);\n            })\n          });\n\n        case 7:\n        case 'end':\n          return _context2.stop();\n      }\n    }\n  }, null, this);\n}\n\nfunction getDefinitionQueryResultForDefinitionNode(path, text, definition) {\n  return {\n    definitions: [getDefinitionForFragmentDefinition(path, text, definition)],\n    queryRange: definition.name ? [getRange(text, definition.name)] : []\n  };\n}\n\nfunction getDefinitionForFragmentDefinition(path, text, definition) {\n  var name = definition.name;\n  (0, _assert2.default)(name, 'Expected ASTNode to have a Name.');\n  return {\n    path: path,\n    position: getPosition(text, definition),\n    range: getRange(text, definition),\n    name: name.value || '',\n    language: LANGUAGE,\n    // This is a file inside the project root, good enough for now\n    projectRoot: path\n  };\n}\n\nfunction getDefinitionForNodeDefinition(path, text, definition) {\n  var name = definition.name;\n  (0, _assert2.default)(name, 'Expected ASTNode to have a Name.');\n  return {\n    path: path,\n    position: getPosition(text, definition),\n    range: getRange(text, definition),\n    name: name.value || '',\n    language: LANGUAGE,\n    // This is a file inside the project root, good enough for now\n    projectRoot: path\n  };\n}","map":null,"metadata":{},"sourceType":"script"}