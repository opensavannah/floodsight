{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('lodash.flowright')) : typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', 'lodash.flowright'], factory) : factory(global['react-apollo'] = {}, global.React, global.PropTypes, global.lodash_flowright);\n})(this, function (exports, React, PropTypes, lodash_flowright) {\n  'use strict';\n\n  function shallowEqual(objA, objB) {\n    if (!objA || !objB) return false;\n    if (objA === objB) return true;\n    var keysA = Object.keys(objA);\n    var keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    for (var i = 0; i < keysA.length; i++) {\n      if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  var __assign = undefined && undefined.__assign || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  var __rest = undefined && undefined.__rest || function (s, e) {\n    var t = {};\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    }\n\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n    }\n    return t;\n  };\n\n  var ObservableQueryRecycler = function () {\n    function ObservableQueryRecycler() {\n      this.observableQueries = [];\n    }\n\n    ObservableQueryRecycler.prototype.recycle = function (observableQuery) {\n      observableQuery.setOptions({\n        fetchPolicy: 'standby',\n        pollInterval: 0,\n        fetchResults: false\n      });\n      this.observableQueries.push({\n        observableQuery: observableQuery,\n        subscription: observableQuery.subscribe({})\n      });\n    };\n\n    ObservableQueryRecycler.prototype.reuse = function (options) {\n      if (this.observableQueries.length <= 0) {\n        return null;\n      }\n\n      var _a = this.observableQueries.pop(),\n          observableQuery = _a.observableQuery,\n          subscription = _a.subscription;\n\n      subscription.unsubscribe();\n\n      var ssr = options.ssr,\n          skip = options.skip,\n          client = options.client,\n          modifiableOpts = __rest(options, [\"ssr\", \"skip\", \"client\"]);\n\n      if (!shallowEqual(modifiableOpts.variables || {}, observableQuery.variables)) return null;\n      observableQuery.setOptions(__assign({}, modifiableOpts, {\n        pollInterval: options.pollInterval,\n        fetchPolicy: options.fetchPolicy\n      }));\n      return observableQuery;\n    };\n\n    return ObservableQueryRecycler;\n  }();\n\n  var __extends$1 = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return function (d, b) {\n      extendStatics(d, b);\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n  }();\n\n  var QueryRecyclerProvider = function (_super) {\n    __extends$1(QueryRecyclerProvider, _super);\n\n    function QueryRecyclerProvider(props) {\n      var _this = _super.call(this, props) || this;\n\n      _this.recyclers = new WeakMap();\n      _this.getQueryRecycler = _this.getQueryRecycler.bind(_this);\n      return _this;\n    }\n\n    QueryRecyclerProvider.prototype.componentWillReceiveProps = function (_, nextContext) {\n      if (this.context.client !== nextContext.client) {\n        this.recyclers = new WeakMap();\n      }\n    };\n\n    QueryRecyclerProvider.prototype.getQueryRecycler = function (component) {\n      if (!this.recyclers.has(component)) {\n        this.recyclers.set(component, new ObservableQueryRecycler());\n      }\n\n      return this.recyclers.get(component);\n    };\n\n    QueryRecyclerProvider.prototype.getChildContext = function () {\n      return {\n        getQueryRecycler: this.getQueryRecycler\n      };\n    };\n\n    QueryRecyclerProvider.prototype.render = function () {\n      return React.Children.only(this.props.children);\n    };\n\n    QueryRecyclerProvider.propTypes = {\n      children: PropTypes.element.isRequired\n    };\n    QueryRecyclerProvider.contextTypes = {\n      client: PropTypes.object\n    };\n    QueryRecyclerProvider.childContextTypes = {\n      getQueryRecycler: PropTypes.func.isRequired\n    };\n    return QueryRecyclerProvider;\n  }(React.Component);\n\n  var __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return function (d, b) {\n      extendStatics(d, b);\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n  }();\n\n  var invariant = require('invariant');\n\n  var ApolloProvider = function (_super) {\n    __extends(ApolloProvider, _super);\n\n    function ApolloProvider(props, context) {\n      var _this = _super.call(this, props, context) || this;\n\n      invariant(props.client, 'ApolloClient was not passed a client instance. Make ' + 'sure you pass in your client via the \"client\" prop.');\n      return _this;\n    }\n\n    ApolloProvider.prototype.getChildContext = function () {\n      return {\n        client: this.props.client\n      };\n    };\n\n    ApolloProvider.prototype.render = function () {\n      return React.createElement(QueryRecyclerProvider, null, React.Children.only(this.props.children));\n    };\n\n    ApolloProvider.propTypes = {\n      client: PropTypes.object.isRequired,\n      children: PropTypes.element.isRequired\n    };\n    ApolloProvider.childContextTypes = {\n      client: PropTypes.object.isRequired\n    };\n    return ApolloProvider;\n  }(React.Component);\n\n  var invariant$2 = require('invariant');\n\n  var DocumentType;\n\n  (function (DocumentType) {\n    DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n    DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n    DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n  })(DocumentType || (DocumentType = {}));\n\n  function parser(document) {\n    var variables, type, name;\n    invariant$2(!!document && !!document.kind, \"Argument of \" + document + \" passed to parser was not a valid GraphQL DocumentNode. You may need to use 'graphql-tag' or another method to convert your operation into a document\");\n    var fragments = document.definitions.filter(function (x) {\n      return x.kind === 'FragmentDefinition';\n    });\n    var queries = document.definitions.filter(function (x) {\n      return x.kind === 'OperationDefinition' && x.operation === 'query';\n    });\n    var mutations = document.definitions.filter(function (x) {\n      return x.kind === 'OperationDefinition' && x.operation === 'mutation';\n    });\n    var subscriptions = document.definitions.filter(function (x) {\n      return x.kind === 'OperationDefinition' && x.operation === 'subscription';\n    });\n    invariant$2(!fragments.length || queries.length || mutations.length || subscriptions.length, \"Passing only a fragment to 'graphql' is not yet supported. You must include a query, subscription or mutation as well\");\n    invariant$2(queries.length + mutations.length + subscriptions.length <= 1, \"react-apollo only supports a query, subscription, or a mutation per HOC. \" + document + \" had \" + queries.length + \" queries, \" + subscriptions.length + \" subscriptions and \" + mutations.length + \" mutations. You can use 'compose' to join multiple operation types to a component\");\n    type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n    if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n    var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;\n    invariant$2(definitions.length === 1, \"react-apollo only supports one defintion per HOC. \" + document + \" had \" + definitions.length + \" definitions. You can use 'compose' to join multiple operation types to a component\");\n    var definition = definitions[0];\n    variables = definition.variableDefinitions || [];\n    var hasName = definition.name && definition.name.kind === 'Name';\n    name = hasName ? definition.name.value : 'data';\n    return {\n      name: name,\n      type: type,\n      variables: variables\n    };\n  }\n\n  var __extends$2 = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return function (d, b) {\n      extendStatics(d, b);\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n  }();\n\n  var __assign$1 = undefined && undefined.__assign || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  var invariant$1 = require('invariant');\n\n  var assign = require('object-assign');\n\n  var pick = require('lodash.pick');\n\n  var hoistNonReactStatics = require('hoist-non-react-statics');\n\n  var defaultMapPropsToOptions = function defaultMapPropsToOptions() {\n    return {};\n  };\n\n  var defaultMapResultToProps = function defaultMapResultToProps(props) {\n    return props;\n  };\n\n  var defaultMapPropsToSkip = function defaultMapPropsToSkip() {\n    return false;\n  };\n\n  function observableQueryFields(observable) {\n    var fields = pick(observable, 'variables', 'refetch', 'fetchMore', 'updateQuery', 'startPolling', 'stopPolling', 'subscribeToMore');\n    Object.keys(fields).forEach(function (key) {\n      if (typeof fields[key] === 'function') {\n        fields[key] = fields[key].bind(observable);\n      }\n    });\n    return fields;\n  }\n\n  function getDisplayName(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  }\n\n  var nextVersion = 0;\n\n  function graphql(document, operationOptions) {\n    if (operationOptions === void 0) {\n      operationOptions = {};\n    }\n\n    var _a = operationOptions.options,\n        options = _a === void 0 ? defaultMapPropsToOptions : _a,\n        _b = operationOptions.skip,\n        skip = _b === void 0 ? defaultMapPropsToSkip : _b,\n        _c = operationOptions.alias,\n        alias = _c === void 0 ? 'Apollo' : _c;\n    var mapPropsToOptions = options;\n    if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = function mapPropsToOptions() {\n      return options;\n    };\n    var mapPropsToSkip = skip;\n    if (typeof mapPropsToSkip !== 'function') mapPropsToSkip = function mapPropsToSkip() {\n      return skip;\n    };\n    var mapResultToProps = operationOptions.props;\n    var operation = parser(document);\n    var version = nextVersion++;\n\n    function wrapWithApolloComponent(WrappedComponent) {\n      var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n      var GraphQL = function (_super) {\n        __extends$2(GraphQL, _super);\n\n        function GraphQL(props, context) {\n          var _this = _super.call(this, props, context) || this;\n\n          _this.previousData = {};\n          _this.version = version;\n          _this.type = operation.type;\n          _this.dataForChildViaMutation = _this.dataForChildViaMutation.bind(_this);\n          _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);\n          return _this;\n        }\n\n        GraphQL.prototype.componentWillMount = function () {\n          if (!this.shouldSkip(this.props)) {\n            this.setInitialProps();\n          }\n        };\n\n        GraphQL.prototype.componentDidMount = function () {\n          this.hasMounted = true;\n          if (this.type === DocumentType.Mutation) return;\n\n          if (!this.shouldSkip(this.props)) {\n            this.subscribeToQuery();\n\n            if (this.refetcherQueue) {\n              var _a = this.refetcherQueue,\n                  args = _a.args,\n                  resolve = _a.resolve,\n                  reject = _a.reject;\n              this.queryObservable.refetch(args).then(resolve).catch(reject);\n            }\n          }\n        };\n\n        GraphQL.prototype.componentWillReceiveProps = function (nextProps, nextContext) {\n          if (this.shouldSkip(nextProps)) {\n            if (!this.shouldSkip(this.props)) {\n              this.unsubscribeFromQuery();\n            }\n\n            return;\n          }\n\n          var client = mapPropsToOptions(nextProps).client;\n\n          if (shallowEqual(this.props, nextProps) && (this.client === client || this.client === nextContext.client)) {\n            return;\n          }\n\n          this.shouldRerender = true;\n\n          if (this.client !== client && this.client !== nextContext.client) {\n            if (client) {\n              this.client = client;\n            } else {\n              this.client = nextContext.client;\n            }\n\n            this.unsubscribeFromQuery();\n            this.queryObservable = null;\n            this.previousData = {};\n            this.updateQuery(nextProps);\n\n            if (!this.shouldSkip(nextProps)) {\n              this.subscribeToQuery();\n            }\n\n            return;\n          }\n\n          if (this.type === DocumentType.Mutation) {\n            return;\n          }\n\n          if (this.type === DocumentType.Subscription && operationOptions.shouldResubscribe && operationOptions.shouldResubscribe(this.props, nextProps)) {\n            this.unsubscribeFromQuery();\n            delete this.queryObservable;\n            this.updateQuery(nextProps);\n            this.subscribeToQuery();\n            return;\n          }\n\n          this.updateQuery(nextProps);\n          this.subscribeToQuery();\n        };\n\n        GraphQL.prototype.componentWillUnmount = function () {\n          if (this.type === DocumentType.Query) {\n            if (this.queryObservable) {\n              var recycler = this.getQueryRecycler();\n\n              if (recycler) {\n                recycler.recycle(this.queryObservable);\n                delete this.queryObservable;\n              }\n            }\n\n            this.unsubscribeFromQuery();\n          }\n\n          if (this.type === DocumentType.Subscription) this.unsubscribeFromQuery();\n          this.hasMounted = false;\n        };\n\n        GraphQL.prototype.getQueryRecycler = function () {\n          return this.context.getQueryRecycler && this.context.getQueryRecycler(GraphQL);\n        };\n\n        GraphQL.prototype.getClient = function (props) {\n          if (this.client) return this.client;\n          var client = mapPropsToOptions(props).client;\n\n          if (client) {\n            this.client = client;\n          } else {\n            this.client = this.context.client;\n          }\n\n          invariant$1(!!this.client, \"Could not find \\\"client\\\" in the context of \" + (\"\\\"\" + graphQLDisplayName + \"\\\". \") + \"Wrap the root component in an <ApolloProvider>\");\n          return this.client;\n        };\n\n        GraphQL.prototype.calculateOptions = function (props, newOpts) {\n          if (props === void 0) {\n            props = this.props;\n          }\n\n          var opts = mapPropsToOptions(props);\n\n          if (newOpts && newOpts.variables) {\n            newOpts.variables = assign({}, opts.variables, newOpts.variables);\n          }\n\n          if (newOpts) opts = assign({}, opts, newOpts);\n          if (opts.variables || !operation.variables.length) return opts;\n          var variables = {};\n\n          for (var _i = 0, _a = operation.variables; _i < _a.length; _i++) {\n            var _b = _a[_i],\n                variable = _b.variable,\n                type = _b.type;\n            if (!variable.name || !variable.name.value) continue;\n\n            if (typeof props[variable.name.value] !== 'undefined') {\n              variables[variable.name.value] = props[variable.name.value];\n              continue;\n            }\n\n            if (type.kind !== 'NonNullType') {\n              variables[variable.name.value] = null;\n              continue;\n            }\n\n            invariant$1(typeof props[variable.name.value] !== 'undefined', \"The operation '\" + operation.name + \"' wrapping '\" + getDisplayName(WrappedComponent) + \"' \" + (\"is expecting a variable: '\" + variable.name.value + \"' but it was not found in the props \") + (\"passed to '\" + graphQLDisplayName + \"'\"));\n          }\n\n          opts = __assign$1({}, opts, {\n            variables: variables\n          });\n          return opts;\n        };\n\n        GraphQL.prototype.calculateResultProps = function (result) {\n          var name = this.type === DocumentType.Mutation ? 'mutate' : 'data';\n          if (operationOptions.name) name = operationOptions.name;\n          var newResult = (_a = {}, _a[name] = result, _a.ownProps = this.props, _a);\n          if (mapResultToProps) return mapResultToProps(newResult);\n          return _b = {}, _b[name] = defaultMapResultToProps(result), _b;\n\n          var _a, _b;\n        };\n\n        GraphQL.prototype.setInitialProps = function () {\n          if (this.type === DocumentType.Mutation) {\n            return;\n          }\n\n          var opts = this.calculateOptions(this.props);\n          this.createQuery(opts);\n        };\n\n        GraphQL.prototype.createQuery = function (opts, props) {\n          if (props === void 0) {\n            props = this.props;\n          }\n\n          if (this.type === DocumentType.Subscription) {\n            this.queryObservable = this.getClient(props).subscribe(assign({\n              query: document\n            }, opts));\n          } else {\n            var recycler = this.getQueryRecycler();\n            var queryObservable = null;\n            if (recycler) queryObservable = recycler.reuse(opts);\n\n            if (queryObservable === null) {\n              this.queryObservable = this.getClient(props).watchQuery(assign({\n                query: document,\n                metadata: {\n                  reactComponent: {\n                    displayName: graphQLDisplayName\n                  }\n                }\n              }, opts));\n            } else {\n              this.queryObservable = queryObservable;\n            }\n          }\n        };\n\n        GraphQL.prototype.updateQuery = function (props) {\n          var opts = this.calculateOptions(props);\n\n          if (!this.queryObservable) {\n            this.createQuery(opts, props);\n          }\n\n          if (this.queryObservable._setOptionsNoResult) {\n            this.queryObservable._setOptionsNoResult(opts);\n          } else {\n            if (this.queryObservable.setOptions) {\n              this.queryObservable.setOptions(opts).catch(function () {\n                return null;\n              });\n            }\n          }\n        };\n\n        GraphQL.prototype.fetchData = function () {\n          if (this.shouldSkip()) return false;\n          if (operation.type === DocumentType.Mutation || operation.type === DocumentType.Subscription) return false;\n          var opts = this.calculateOptions();\n          if (opts.ssr === false) return false;\n\n          if (opts.fetchPolicy === 'network-only' || opts.fetchPolicy === 'cache-and-network') {\n            opts.fetchPolicy = 'cache-first';\n          }\n\n          var observable = this.getClient(this.props).watchQuery(assign({\n            query: document\n          }, opts));\n          var result = observable.currentResult();\n\n          if (result.loading) {\n            return observable.result();\n          } else {\n            return false;\n          }\n        };\n\n        GraphQL.prototype.subscribeToQuery = function () {\n          var _this = this;\n\n          if (this.querySubscription) {\n            return;\n          }\n\n          var next = function next(results) {\n            if (_this.type === DocumentType.Subscription) {\n              _this.lastSubscriptionData = results;\n            }\n\n            var clashingKeys = Object.keys(observableQueryFields(results.data));\n            invariant$1(clashingKeys.length === 0, \"the result of the '\" + graphQLDisplayName + \"' operation contains keys that \" + \"conflict with the return object.\" + clashingKeys.map(function (k) {\n              return \"'\" + k + \"'\";\n            }).join(', ') + \" not allowed.\");\n\n            _this.forceRenderChildren();\n          };\n\n          var handleError = function handleError(error) {\n            if (error.hasOwnProperty('graphQLErrors')) return next({\n              error: error\n            });\n            throw error;\n          };\n\n          this.querySubscription = this.queryObservable.subscribe({\n            next: next,\n            error: handleError\n          });\n        };\n\n        GraphQL.prototype.unsubscribeFromQuery = function () {\n          if (this.querySubscription) {\n            this.querySubscription.unsubscribe();\n            delete this.querySubscription;\n          }\n        };\n\n        GraphQL.prototype.shouldSkip = function (props) {\n          if (props === void 0) {\n            props = this.props;\n          }\n\n          return mapPropsToSkip(props) || mapPropsToOptions(props).skip;\n        };\n\n        GraphQL.prototype.forceRenderChildren = function () {\n          this.shouldRerender = true;\n          if (this.hasMounted) this.forceUpdate();\n        };\n\n        GraphQL.prototype.getWrappedInstance = function () {\n          invariant$1(operationOptions.withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options\");\n          return this.wrappedInstance;\n        };\n\n        GraphQL.prototype.setWrappedInstance = function (ref) {\n          this.wrappedInstance = ref;\n        };\n\n        GraphQL.prototype.dataForChildViaMutation = function (mutationOpts) {\n          var opts = this.calculateOptions(this.props, mutationOpts);\n          if (typeof opts.variables === 'undefined') delete opts.variables;\n          opts.mutation = document;\n          return this.getClient(this.props).mutate(opts);\n        };\n\n        GraphQL.prototype.dataForChild = function () {\n          var _this = this;\n\n          if (this.type === DocumentType.Mutation) {\n            return this.dataForChildViaMutation;\n          }\n\n          var opts = this.calculateOptions(this.props);\n          var data = {};\n          assign(data, observableQueryFields(this.queryObservable));\n\n          if (this.type === DocumentType.Subscription) {\n            assign(data, {\n              loading: !this.lastSubscriptionData,\n              variables: opts.variables\n            }, this.lastSubscriptionData && this.lastSubscriptionData.data);\n          } else {\n            var currentResult = this.queryObservable.currentResult();\n            var loading = currentResult.loading,\n                error_1 = currentResult.error,\n                networkStatus = currentResult.networkStatus;\n            assign(data, {\n              loading: loading,\n              networkStatus: networkStatus\n            });\n            var logErrorTimeoutId_1 = setTimeout(function () {\n              if (error_1) {\n                console.error(\"Unhandled (in react-apollo:\" + graphQLDisplayName + \")\", error_1.stack || error_1);\n              }\n            }, 10);\n            Object.defineProperty(data, 'error', {\n              configurable: true,\n              enumerable: true,\n              get: function get() {\n                clearTimeout(logErrorTimeoutId_1);\n                return error_1;\n              }\n            });\n\n            if (loading) {\n              assign(data, this.previousData, currentResult.data);\n            } else if (error_1) {\n              assign(data, (this.queryObservable.getLastResult() || {}).data);\n            } else {\n              assign(data, currentResult.data);\n              this.previousData = currentResult.data;\n            }\n\n            if (!this.querySubscription) {\n              data.refetch = function (args) {\n                return new Promise(function (r, f) {\n                  _this.refetcherQueue = {\n                    resolve: r,\n                    reject: f,\n                    args: args\n                  };\n                });\n              };\n            }\n          }\n\n          return data;\n        };\n\n        GraphQL.prototype.render = function () {\n          if (this.shouldSkip()) {\n            if (operationOptions.withRef) {\n              return React.createElement(WrappedComponent, assign({}, this.props, {\n                ref: this.setWrappedInstance\n              }));\n            }\n\n            return React.createElement(WrappedComponent, this.props);\n          }\n\n          var _a = this,\n              shouldRerender = _a.shouldRerender,\n              renderedElement = _a.renderedElement,\n              props = _a.props;\n\n          this.shouldRerender = false;\n\n          if (!shouldRerender && renderedElement && renderedElement.type === WrappedComponent) {\n            return renderedElement;\n          }\n\n          var data = this.dataForChild();\n          var clientProps = this.calculateResultProps(data);\n          var mergedPropsAndData = assign({}, props, clientProps);\n          if (operationOptions.withRef) mergedPropsAndData.ref = this.setWrappedInstance;\n          this.renderedElement = React.createElement(WrappedComponent, mergedPropsAndData);\n          return this.renderedElement;\n        };\n\n        GraphQL.displayName = graphQLDisplayName;\n        GraphQL.WrappedComponent = WrappedComponent;\n        GraphQL.contextTypes = {\n          client: PropTypes.object,\n          getQueryRecycler: PropTypes.func\n        };\n        return GraphQL;\n      }(React.Component);\n\n      return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n    }\n\n    return wrapWithApolloComponent;\n  }\n\n  var __extends$3 = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return function (d, b) {\n      extendStatics(d, b);\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n  }();\n\n  var invariant$3 = require('invariant');\n\n  var assign$1 = require('object-assign');\n\n  var hoistNonReactStatics$1 = require('hoist-non-react-statics');\n\n  function getDisplayName$1(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  }\n\n  function withApollo(WrappedComponent, operationOptions) {\n    if (operationOptions === void 0) {\n      operationOptions = {};\n    }\n\n    var withDisplayName = \"withApollo(\" + getDisplayName$1(WrappedComponent) + \")\";\n\n    var WithApollo = function (_super) {\n      __extends$3(WithApollo, _super);\n\n      function WithApollo(props, context) {\n        var _this = _super.call(this, props, context) || this;\n\n        _this.client = context.client;\n        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);\n        invariant$3(!!_this.client, \"Could not find \\\"client\\\" in the context of \" + (\"\\\"\" + withDisplayName + \"\\\". \") + \"Wrap the root component in an <ApolloProvider>\");\n        return _this;\n      }\n\n      WithApollo.prototype.getWrappedInstance = function () {\n        invariant$3(operationOptions.withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options\");\n        return this.wrappedInstance;\n      };\n\n      WithApollo.prototype.setWrappedInstance = function (ref) {\n        this.wrappedInstance = ref;\n      };\n\n      WithApollo.prototype.render = function () {\n        var props = assign$1({}, this.props);\n        props.client = this.client;\n        if (operationOptions.withRef) props.ref = this.setWrappedInstance;\n        return React.createElement(WrappedComponent, props);\n      };\n\n      WithApollo.displayName = withDisplayName;\n      WithApollo.WrappedComponent = WrappedComponent;\n      WithApollo.contextTypes = {\n        client: PropTypes.object.isRequired\n      };\n      return WithApollo;\n    }(React.Component);\n\n    return hoistNonReactStatics$1(WithApollo, WrappedComponent, {});\n  }\n\n  var assign$2 = require('object-assign');\n\n  function walkTree(element$$1, context, visitor) {\n    if (Array.isArray(element$$1)) {\n      element$$1.forEach(function (item) {\n        return walkTree(item, context, visitor);\n      });\n      return;\n    }\n\n    if (element$$1 == null) return;\n    var Component$$1 = element$$1.type;\n\n    if (typeof Component$$1 === 'function') {\n      var props = assign$2({}, Component$$1.defaultProps, element$$1.props);\n      var childContext = context;\n      var child = void 0;\n\n      if (Component$$1.prototype && Component$$1.prototype.isReactComponent) {\n        var _component = Component$$1;\n        var instance_1 = new _component(props, context);\n        instance_1.props = instance_1.props || props;\n        instance_1.context = instance_1.context || context;\n        instance_1.state = instance_1.state || null;\n\n        instance_1.setState = function (newState) {\n          if (typeof newState === 'function') {\n            newState = newState(instance_1.state, instance_1.props, instance_1.context);\n          }\n\n          instance_1.state = assign$2({}, instance_1.state, newState);\n        };\n\n        if (instance_1.componentWillMount) {\n          instance_1.componentWillMount();\n        }\n\n        if (instance_1.getChildContext) {\n          childContext = assign$2({}, context, instance_1.getChildContext());\n        }\n\n        if (visitor(element$$1, instance_1, context) === false) {\n          return;\n        }\n\n        child = instance_1.render();\n      } else {\n        if (visitor(element$$1, null, context) === false) {\n          return;\n        }\n\n        var _component = Component$$1;\n        child = _component(props, context);\n      }\n\n      if (child) {\n        if (Array.isArray(child)) {\n          child.forEach(function (item) {\n            return walkTree(item, context, visitor);\n          });\n        } else {\n          walkTree(child, childContext, visitor);\n        }\n      }\n    } else {\n      if (visitor(element$$1, null, context) === false) {\n        return;\n      }\n\n      if (element$$1.props && element$$1.props.children) {\n        React.Children.forEach(element$$1.props.children, function (child) {\n          if (child) {\n            walkTree(child, context, visitor);\n          }\n        });\n      }\n    }\n  }\n\n  function getQueriesFromTree(_a, fetchRoot) {\n    var rootElement = _a.rootElement,\n        _b = _a.rootContext,\n        rootContext = _b === void 0 ? {} : _b;\n\n    if (fetchRoot === void 0) {\n      fetchRoot = true;\n    }\n\n    var queries = [];\n    walkTree(rootElement, rootContext, function (element$$1, instance, context) {\n      var skipRoot = !fetchRoot && element$$1 === rootElement;\n\n      if (instance && typeof instance.fetchData === 'function' && !skipRoot) {\n        var query = instance.fetchData();\n\n        if (query) {\n          queries.push({\n            query: query,\n            element: element$$1,\n            context: context\n          });\n          return false;\n        }\n      }\n    });\n    return queries;\n  }\n\n  function getDataFromTree(rootElement, rootContext, fetchRoot) {\n    if (rootContext === void 0) {\n      rootContext = {};\n    }\n\n    if (fetchRoot === void 0) {\n      fetchRoot = true;\n    }\n\n    var queries = getQueriesFromTree({\n      rootElement: rootElement,\n      rootContext: rootContext\n    }, fetchRoot);\n    if (!queries.length) return Promise.resolve();\n    var errors = [];\n    var mappedQueries = queries.map(function (_a) {\n      var query = _a.query,\n          element$$1 = _a.element,\n          context = _a.context;\n      return query.then(function (_) {\n        return getDataFromTree(element$$1, context, false);\n      }).catch(function (e) {\n        return errors.push(e);\n      });\n    });\n    return Promise.all(mappedQueries).then(function (_) {\n      if (errors.length > 0) {\n        var error = errors.length === 1 ? errors[0] : new Error(errors.length + \" errors were thrown when executing your GraphQL queries.\");\n        error.queryErrors = errors;\n        throw error;\n      }\n    });\n  }\n\n  exports.compose = lodash_flowright;\n  exports.ApolloProvider = ApolloProvider;\n  exports.graphql = graphql;\n  exports.withApollo = withApollo;\n  exports.getDataFromTree = getDataFromTree;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}