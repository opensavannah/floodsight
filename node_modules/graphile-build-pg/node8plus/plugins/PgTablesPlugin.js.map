{"version":3,"sources":["../../src/plugins/PgTablesPlugin.js"],"names":["base64","str","Buffer","from","String","toString","hasNonNullKey","row","Array","isArray","__identifiers","every","i","k","hasOwnProperty","PgTablesPlugin","builder","pgForbidSetofFunctionsToReturnNull","handleNullRow","hook","_","build","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","newWithHooks","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pg2GqlMapper","gql2pg","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLID","GraphQLList","GraphQLInputObjectType","inflection","describePgEntity","sqlCommentByAddingTags","nullableIf","condition","Type","Cursor","class","forEach","table","tablePgType","type","find","category","namespaceId","classId","id","Error","arrayTablePgType","arrayItemTypeId","primaryKeyConstraint","constraint","filter","con","primaryKeys","keyAttributeNums","map","num","attributeByClassIdAndNum","attributes","attribute","attr","sort","a1","a2","tableTypeName","tableType","shouldHaveNodeId","isSelectable","namespace","length","TableType","TablePatchType","TableBaseInputType","cb","description","name","interfaces","fields","addDataGeneratorForField","Self","pgQuery","queryBuilder","select","fragment","join","key","getTableAlias","identifier","resolve","data","__origin","pgIntrospection","isPgRowType","isPgCompoundType","pgCreateInputFields","pgPatchInputFields","pgBaseInputFields","inputType","isInputType","pgAddSubfield","fieldName","attrName","pgType","spec","typeModifier","patchType","isPgPatch","baseInputType","isPgBaseInput","unmap","obj","modifier","fieldLookup","attr2sql","column","inputField","v","namespaceName","null","EdgeType","edge","fieldWithHooks","recurseDataGeneratorsForField","cursor","addDataGenerator","usesCursor","__cursor","JSON","stringify","isCursorField","node","isEdgeType","isPgRowEdgeType","nodeType","PageInfo","connection","nodes","edges","pageInfo","isConnectionType","isPgRowConnectionType","edgeType","_set","RelevantTableInputType"],"mappings":"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","file":"PgTablesPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nconst hasNonNullKey = row => {\n  if (\n    Array.isArray(row.__identifiers) &&\n    row.__identifiers.every(i => i != null)\n  ) {\n    return true;\n  }\n  for (const k in row) {\n    if (row.hasOwnProperty(k)) {\n      if ((k[0] !== \"_\" || k[1] !== \"_\") && row[k] !== null) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nexport default (function PgTablesPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false }\n) {\n  const handleNullRow = pgForbidSetofFunctionsToReturnNull\n    ? row => row\n    : row => {\n        if (hasNonNullKey(row)) {\n          return row;\n        } else {\n          return null;\n        }\n      };\n\n  builder.hook(\"init\", (_, build) => {\n    const {\n      getNodeIdForTypeAndIdentifiers,\n      nodeIdFieldName,\n      newWithHooks,\n      pgSql: sql,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      getTypeByName,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      pgRegisterGqlTypeByTypeId,\n      pgRegisterGqlInputTypeByTypeId,\n      pg2GqlMapper,\n      gql2pg,\n      graphql: {\n        GraphQLObjectType,\n        GraphQLNonNull,\n        GraphQLID,\n        GraphQLList,\n        GraphQLInputObjectType,\n      },\n      inflection,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const nullableIf = (condition, Type) =>\n      condition ? Type : new GraphQLNonNull(Type);\n    const Cursor = getTypeByName(\"Cursor\");\n    introspectionResultsByKind.class.forEach(table => {\n      const tablePgType = introspectionResultsByKind.type.find(\n        type =>\n          type.type === \"c\" &&\n          type.category === \"C\" &&\n          type.namespaceId === table.namespaceId &&\n          type.classId === table.id\n      );\n      if (!tablePgType) {\n        throw new Error(\"Could not determine the type for this table\");\n      }\n      const arrayTablePgType = introspectionResultsByKind.type.find(\n        type => type.arrayItemTypeId === tablePgType.id\n      );\n      /*\n        table =\n          { kind: 'class',\n            id: '6484790',\n            name: 'bundle',\n            description: null,\n            namespaceId: '6484381',\n            typeId: '6484792',\n            isSelectable: true,\n            isInsertable: true,\n            isUpdatable: true,\n            isDeletable: true }\n        */\n      const primaryKeyConstraint = introspectionResultsByKind.constraint\n        .filter(con => con.classId === table.id)\n        .filter(con => con.type === \"p\")[0];\n      const primaryKeys =\n        primaryKeyConstraint &&\n        primaryKeyConstraint.keyAttributeNums.map(\n          num =>\n            introspectionResultsByKind.attributeByClassIdAndNum[table.id][num]\n        );\n      const attributes = introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .sort((a1, a2) => a1.num - a2.num);\n      const tableTypeName = inflection.tableType(table);\n      const shouldHaveNodeId: boolean =\n        nodeIdFieldName &&\n        table.isSelectable &&\n        table.namespace &&\n        primaryKeys &&\n        primaryKeys.length\n          ? true\n          : false;\n      let TableType;\n      let TablePatchType;\n      let TableBaseInputType;\n      pgRegisterGqlTypeByTypeId(\n        tablePgType.id,\n        cb => {\n          if (TableType) {\n            return TableType;\n          }\n          if (pg2GqlMapper[tablePgType.id]) {\n            // Already handled\n            throw new Error(\n              `Register was called but there's already a mapper in place for '${\n                tablePgType.id\n              }'!`\n            );\n          }\n          TableType = newWithHooks(\n            GraphQLObjectType,\n            {\n              description: table.description || tablePgType.description,\n              name: tableTypeName,\n              interfaces: () => {\n                if (shouldHaveNodeId) {\n                  return [getTypeByName(\"Node\")];\n                } else {\n                  return [];\n                }\n              },\n              fields: ({ addDataGeneratorForField, Self }) => {\n                const fields = {};\n                if (shouldHaveNodeId) {\n                  // Enable nodeId interface\n                  addDataGeneratorForField(nodeIdFieldName, () => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(\n                          sql.fragment`json_build_array(${sql.join(\n                            primaryKeys.map(\n                              key =>\n                                sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                  key.name\n                                )}`\n                            ),\n                            \", \"\n                          )})`,\n                          \"__identifiers\"\n                        );\n                      },\n                    };\n                  });\n                  fields[nodeIdFieldName] = {\n                    description:\n                      \"A globally unique identifier. Can be used in various places throughout the system to identify this single value.\",\n                    type: new GraphQLNonNull(GraphQLID),\n                    resolve(data) {\n                      return (\n                        data.__identifiers &&\n                        getNodeIdForTypeAndIdentifiers(\n                          Self,\n                          ...data.__identifiers\n                        )\n                      );\n                    },\n                  };\n                }\n                return fields;\n              },\n            },\n            {\n              __origin: `Adding table type for ${describePgEntity(\n                table\n              )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                {\n                  name: \"newNameHere\",\n                }\n              )}`,\n              pgIntrospection: table,\n              isPgRowType: table.isSelectable,\n              isPgCompoundType: !table.isSelectable,\n            }\n          );\n          cb(TableType);\n          const pgCreateInputFields = {};\n          const pgPatchInputFields = {};\n          const pgBaseInputFields = {};\n          newWithHooks(\n            GraphQLInputObjectType,\n            {\n              description: `An input for mutations affecting \\`${tableTypeName}\\``,\n              name: inflection.inputType(TableType),\n            },\n            {\n              __origin: `Adding table input type for ${describePgEntity(\n                table\n              )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                {\n                  name: \"newNameHere\",\n                }\n              )}`,\n              pgIntrospection: table,\n              isInputType: true,\n              isPgRowType: table.isSelectable,\n              isPgCompoundType: !table.isSelectable,\n              pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                pgCreateInputFields[fieldName] = {\n                  name: attrName,\n                  type: pgType,\n                  typeModifier,\n                };\n                return spec;\n              },\n            },\n            true // If no fields, skip type automatically\n          );\n\n          if (table.isSelectable) {\n            // XXX: these don't belong here; but we have to keep them here\n            // because third-party code depends on `getTypeByName` to find\n            // them; so we have to register them ahead of time. A better\n            // approach is to use the modifier to specify the type you need,\n            // 'patch' or 'base', so they can be registered just in time.\n            TablePatchType = newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: `Represents an update to a \\`${tableTypeName}\\`. Fields that are set will be updated.`,\n                name: inflection.patchType(TableType),\n              },\n              {\n                __origin: `Adding table patch type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                isPgPatch: true,\n                pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                  pgPatchInputFields[fieldName] = {\n                    name: attrName,\n                    type: pgType,\n                    typeModifier,\n                  };\n                  return spec;\n                },\n              },\n              true // Safe to skip this if no fields support updating\n            );\n            TableBaseInputType = newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: `An input representation of \\`${tableTypeName}\\` with nullable fields.`,\n                name: inflection.baseInputType(TableType),\n              },\n              {\n                __origin: `Adding table base input type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                isPgBaseInput: true,\n                pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                  pgBaseInputFields[fieldName] = {\n                    name: attrName,\n                    type: pgType,\n                    typeModifier,\n                  };\n                  return spec;\n                },\n              }\n            );\n          }\n\n          pg2GqlMapper[tablePgType.id] = {\n            map: _ => _,\n            unmap: (obj, modifier) => {\n              let fieldLookup;\n              if (modifier === \"patch\") {\n                fieldLookup = pgPatchInputFields;\n              } else if (modifier === \"base\") {\n                fieldLookup = pgBaseInputFields;\n              } else {\n                fieldLookup = pgCreateInputFields;\n              }\n\n              const attr2sql = attr => {\n                // TODO: this should use `fieldInput[*].name` to find the attribute\n                const fieldName = inflection.column(attr);\n                const inputField = fieldLookup[fieldName];\n                const v = obj[fieldName];\n                if (inputField && v != null) {\n                  const { type, typeModifier } = inputField;\n                  return sql.fragment`${gql2pg(\n                    v,\n                    type,\n                    typeModifier\n                  )}::${sql.identifier(type.namespaceName, type.name)}`;\n                } else {\n                  return sql.null; // TODO: return default instead.\n                }\n              };\n\n              return sql.fragment`row(${sql.join(\n                attributes.map(attr2sql),\n                \",\"\n              )})::${sql.identifier(\n                tablePgType.namespaceName,\n                tablePgType.name\n              )}`;\n            },\n          };\n\n          const EdgeType = newWithHooks(\n            GraphQLObjectType,\n            {\n              description: `A \\`${tableTypeName}\\` edge in the connection.`,\n              name: inflection.edge(TableType.name),\n              fields: ({ fieldWithHooks, recurseDataGeneratorsForField }) => {\n                recurseDataGeneratorsForField(\"node\");\n                return {\n                  cursor: fieldWithHooks(\n                    \"cursor\",\n                    ({ addDataGenerator }) => {\n                      addDataGenerator(() => ({\n                        usesCursor: [true],\n                      }));\n                      return {\n                        description: \"A cursor for use in pagination.\",\n                        type: Cursor,\n                        resolve(data) {\n                          return (\n                            data.__cursor &&\n                            base64(JSON.stringify(data.__cursor))\n                          );\n                        },\n                      };\n                    },\n                    {\n                      isCursorField: true,\n                    }\n                  ),\n                  node: {\n                    description: `The \\`${tableTypeName}\\` at the end of the edge.`,\n                    type: nullableIf(\n                      !pgForbidSetofFunctionsToReturnNull,\n                      TableType\n                    ),\n                    resolve(data) {\n                      return handleNullRow(data);\n                    },\n                  },\n                };\n              },\n            },\n            {\n              __origin: `Adding table edge type for ${describePgEntity(\n                table\n              )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                {\n                  name: \"newNameHere\",\n                }\n              )}`,\n              isEdgeType: true,\n              isPgRowEdgeType: true,\n              nodeType: TableType,\n              pgIntrospection: table,\n            }\n          );\n          const PageInfo = getTypeByName(\"PageInfo\");\n          /*const ConnectionType = */\n          newWithHooks(\n            GraphQLObjectType,\n            {\n              description: `A connection to a list of \\`${tableTypeName}\\` values.`,\n              name: inflection.connection(TableType.name),\n              fields: ({ recurseDataGeneratorsForField }) => {\n                recurseDataGeneratorsForField(\"edges\");\n                recurseDataGeneratorsForField(\"nodes\");\n                recurseDataGeneratorsForField(\"pageInfo\");\n                return {\n                  nodes: {\n                    description: `A list of \\`${tableTypeName}\\` objects.`,\n                    type: new GraphQLNonNull(\n                      new GraphQLList(\n                        nullableIf(\n                          !pgForbidSetofFunctionsToReturnNull,\n                          TableType\n                        )\n                      )\n                    ),\n                    resolve(data) {\n                      return data.data.map(handleNullRow);\n                    },\n                  },\n                  edges: {\n                    description: `A list of edges which contains the \\`${tableTypeName}\\` and cursor to aid in pagination.`,\n                    type: new GraphQLNonNull(\n                      new GraphQLList(new GraphQLNonNull(EdgeType))\n                    ),\n                    resolve(data) {\n                      return data.data;\n                    },\n                  },\n                  pageInfo: PageInfo && {\n                    description: \"Information to aid in pagination.\",\n                    type: new GraphQLNonNull(PageInfo),\n                    resolve(data) {\n                      return data;\n                    },\n                  },\n                };\n              },\n            },\n            {\n              __origin: `Adding table connection type for ${describePgEntity(\n                table\n              )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                {\n                  name: \"newNameHere\",\n                }\n              )}`,\n              isConnectionType: true,\n              isPgRowConnectionType: true,\n              edgeType: EdgeType,\n              nodeType: TableType,\n              pgIntrospection: table,\n            }\n          );\n        },\n        true\n      );\n      pgRegisterGqlInputTypeByTypeId(\n        tablePgType.id,\n        (_set, modifier) => {\n          // This must come first, it triggers creation of all the types\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            tablePgType.id,\n            null\n          );\n          // This must come after the pgGetGqlTypeByTypeIdAndModifier call\n          if (modifier === \"patch\") {\n            // TODO: v5: move the definition from above down here\n            return TablePatchType;\n          }\n          if (modifier === \"base\") {\n            // TODO: v5: move the definition from above down here\n            return TableBaseInputType;\n          }\n          if (TableType) {\n            return getTypeByName(inflection.inputType(TableType));\n          }\n          return null;\n        },\n        true\n      );\n\n      if (arrayTablePgType) {\n        // Note: these do not return\n        //\n        // `new GraphQLList(new GraphQLNonNull(...))`\n        //\n        // because it's possible to return null entries from postgresql\n        // functions. We should probably add a flag to instead export\n        // the non-null version as that's more typical.\n        pgRegisterGqlTypeByTypeId(\n          arrayTablePgType.id,\n          () => {\n            const TableType = pgGetGqlTypeByTypeIdAndModifier(\n              tablePgType.id,\n              null\n            );\n            return new GraphQLList(TableType);\n          },\n          true\n        );\n        pgRegisterGqlInputTypeByTypeId(\n          arrayTablePgType.id,\n          (_set, modifier) => {\n            const RelevantTableInputType = pgGetGqlInputTypeByTypeIdAndModifier(\n              tablePgType.id,\n              modifier\n            );\n            if (RelevantTableInputType) {\n              return new GraphQLList(RelevantTableInputType);\n            }\n          },\n          true\n        );\n      }\n    });\n    return _;\n  });\n}: Plugin);\n"]}