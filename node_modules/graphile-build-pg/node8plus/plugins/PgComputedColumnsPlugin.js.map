{"version":3,"sources":["../../src/plugins/PgComputedColumnsPlugin.js"],"names":["PgComputedColumnsPlugin","builder","pgSimpleCollections","hasConnections","hasSimpleCollections","hook","fields","build","context","scope","isPgRowType","isPgCompoundType","isInputType","pgIntrospection","table","fieldWithHooks","Self","kind","namespace","extend","pgIntrospectionResultsByKind","introspectionResultsByKind","inflection","pgOmit","omit","pgMakeProcField","makeProcField","swallowError","describePgEntity","sqlCommentByAddingTags","tableType","type","filter","namespaceId","classId","id","Error","procedure","proc","isStable","name","startsWith","argTypeIds","length","reduce","memo","argTypes","map","typeId","typeById","slice","some","class","isSelectable","pseudoColumnName","substr","makeField","forceList","fieldName","computedColumnList","computedColumn","computed","e","returnsSet"],"mappings":"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","file":"PgComputedColumnsPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nexport default (function PgComputedColumnsPlugin(\n  builder,\n  { pgSimpleCollections }\n) {\n  const hasConnections = pgSimpleCollections !== \"only\";\n  const hasSimpleCollections =\n    pgSimpleCollections === \"only\" || pgSimpleCollections === \"both\";\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isInputType,\n        pgIntrospection: table,\n      },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (\n      isInputType ||\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\" ||\n      !table.namespace\n    ) {\n      return fields;\n    }\n    const {\n      extend,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      inflection,\n      pgOmit: omit,\n      pgMakeProcField: makeProcField,\n      swallowError,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const tableType = introspectionResultsByKind.type.filter(\n      type =>\n        type.type === \"c\" &&\n        type.namespaceId === table.namespaceId &&\n        type.classId === table.id\n    )[0];\n    if (!tableType) {\n      throw new Error(\"Could not determine the type for this table\");\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.procedure\n        .filter(proc => proc.isStable)\n        .filter(proc => proc.namespaceId === table.namespaceId)\n        .filter(proc => proc.name.startsWith(`${table.name}_`))\n        .filter(proc => proc.argTypeIds.length > 0)\n        .filter(proc => proc.argTypeIds[0] === tableType.id)\n        .filter(proc => !omit(proc, \"execute\"))\n        .reduce((memo, proc) => {\n          /*\n            proc =\n              { kind: 'procedure',\n                name: 'integration_webhook_secret',\n                description: null,\n                namespaceId: '6484381',\n                isStrict: false,\n                returnsSet: false,\n                isStable: true,\n                returnTypeId: '2950',\n                argTypeIds: [ '6484569' ],\n                argNames: [ 'integration' ],\n                argDefaultsNum: 0 }\n            */\n          const argTypes = proc.argTypeIds.map(\n            typeId => introspectionResultsByKind.typeById[typeId]\n          );\n          if (\n            argTypes\n              .slice(1)\n              .some(\n                type =>\n                  type.type === \"c\" && type.class && type.class.isSelectable\n              )\n          ) {\n            // Accepts two input tables? Skip.\n            return memo;\n          }\n\n          const pseudoColumnName = proc.name.substr(table.name.length + 1);\n          function makeField(forceList) {\n            const fieldName = forceList\n              ? inflection.computedColumnList(pseudoColumnName, proc, table)\n              : inflection.computedColumn(pseudoColumnName, proc, table);\n            try {\n              memo = extend(\n                memo,\n                {\n                  [fieldName]: makeProcField(fieldName, proc, build, {\n                    fieldWithHooks,\n                    computed: true,\n                    forceList,\n                  }),\n                },\n                `Adding computed column for ${describePgEntity(\n                  proc\n                )}. You can rename this field with:\\n\\n  ${sqlCommentByAddingTags(\n                  proc,\n                  {\n                    fieldName: \"newNameHere\",\n                  }\n                )}`\n              );\n            } catch (e) {\n              swallowError(e);\n            }\n          }\n          if (!proc.returnsSet || hasConnections) {\n            makeField(false);\n          }\n          if (proc.returnsSet && hasSimpleCollections) {\n            makeField(true);\n          }\n          return memo;\n        }, {}),\n      `Adding computed column to '${Self.name}'`\n    );\n  });\n}: Plugin);\n"]}