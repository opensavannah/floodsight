{"version":3,"sources":["../../src/plugins/PgBackwardRelationPlugin.js"],"names":["debug","OMIT","DEPRECATED","ONLY","PgBackwardRelationPlugin","builder","pgLegacyRelations","pgSimpleCollections","hasConnections","hasSimpleCollections","legacyRelationMode","only","deprecated","hook","fields","build","context","extend","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","graphql","GraphQLNonNull","GraphQLList","inflection","pgQueryFromResolveData","queryFromResolveData","pgAddStartEndCursor","addStartEndCursor","pgOmit","omit","sqlCommentByAddingTags","describePgEntity","scope","isPgRowType","pgIntrospection","foreignTable","fieldWithHooks","Self","kind","foreignKeyConstraints","constraint","filter","con","type","foreignClassId","id","foreignAttributes","attribute","attr","classId","sort","a","b","num","reduce","memo","table","classById","tableTypeName","tableType","gqlTableType","foreignTableTypeName","gqlForeignTableType","Error","name","schema","namespace","attributes","keys","keyAttributeNums","map","foreignKeys","foreignKeyAttributeNums","every","_","some","key","isUnique","find","c","length","n","i","isDeprecated","singleRelationFieldName","singleRelationByKeysBackwards","primaryKeyConstraint","primaryKeys","shouldAddSingleRelation","shouldAddManyRelation","getDataFromParsedResolveInfoFragment","addDataGenerator","parsedResolveInfoFragment","pgQuery","queryBuilder","select","resolveData","tableAlias","identifier","Symbol","foreignTableAlias","getTableAlias","query","asJson","addNullCase","withPagination","innerQueryBuilder","parentQueryBuilder","forEach","where","fragment","alias","description","tags","backwardDescription","args","resolve","data","_args","_context","resolveInfo","safeAlias","pgFieldIntrospection","isPgBackwardSingleRelationField","foreignSingleFieldName","makeFields","isConnection","manyRelationFieldName","manyRelationByKeys","manyRelationByKeysSimple","ConnectionType","TableType","withPaginationAsFields","asJsonAggregate","beforeLock","isOrderUnique","cursorPrefix","orderBy","setOrderIsUnique","connection","deprecationReason","undefined","isPgFieldConnection","isPgFieldSimpleCollection","isPgBackwardRelationField"],"mappings":"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","file":"PgBackwardRelationPlugin.js","sourcesContent":["// @flow\nimport debugFactory from \"debug\";\n\nimport type { Plugin } from \"graphile-build\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nconst OMIT = 0;\nconst DEPRECATED = 1;\nconst ONLY = 2;\n\nexport default (function PgBackwardRelationPlugin(\n  builder,\n  { pgLegacyRelations, pgSimpleCollections }\n) {\n  const hasConnections = pgSimpleCollections !== \"only\";\n  const hasSimpleCollections =\n    pgSimpleCollections === \"only\" || pgSimpleCollections === \"both\";\n  const legacyRelationMode =\n    {\n      only: ONLY,\n      deprecated: DEPRECATED,\n    }[pgLegacyRelations] || OMIT;\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      getTypeByName,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      getSafeAliasFromResolveInfo,\n      getSafeAliasFromAlias,\n      graphql: { GraphQLNonNull, GraphQLList },\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgAddStartEndCursor: addStartEndCursor,\n      pgOmit: omit,\n      sqlCommentByAddingTags,\n      describePgEntity,\n    } = build;\n    const {\n      scope: { isPgRowType, pgIntrospection: foreignTable },\n      fieldWithHooks,\n      Self,\n    } = context;\n    if (!isPgRowType || !foreignTable || foreignTable.kind !== \"class\") {\n      return fields;\n    }\n    // This is a relation in which WE are foreign\n    const foreignKeyConstraints = introspectionResultsByKind.constraint\n      .filter(con => con.type === \"f\")\n      .filter(con => con.foreignClassId === foreignTable.id);\n    const foreignAttributes = introspectionResultsByKind.attribute\n      .filter(attr => attr.classId === foreignTable.id)\n      .sort((a, b) => a.num - b.num);\n\n    return extend(\n      fields,\n      foreignKeyConstraints.reduce((memo, constraint) => {\n        if (omit(constraint, \"read\")) {\n          return memo;\n        }\n        const table = introspectionResultsByKind.classById[constraint.classId];\n        const tableTypeName = inflection.tableType(table);\n        const gqlTableType = pgGetGqlTypeByTypeIdAndModifier(\n          table.type.id,\n          null\n        );\n        if (!gqlTableType) {\n          debug(\n            `Could not determine type for table with id ${constraint.classId}`\n          );\n          return memo;\n        }\n        const foreignTable =\n          introspectionResultsByKind.classById[constraint.foreignClassId];\n        const foreignTableTypeName = inflection.tableType(foreignTable);\n        const gqlForeignTableType = pgGetGqlTypeByTypeIdAndModifier(\n          foreignTable.type.id,\n          null\n        );\n        if (!gqlForeignTableType) {\n          debug(\n            `Could not determine type for foreign table with id ${\n              constraint.foreignClassId\n            }`\n          );\n          return memo;\n        }\n        if (!table) {\n          throw new Error(\n            `Could not find the table that referenced us (constraint: ${\n              constraint.name\n            })`\n          );\n        }\n        const schema = table.namespace;\n\n        const attributes = introspectionResultsByKind.attribute.filter(\n          attr => attr.classId === table.id\n        );\n\n        const keys = constraint.keyAttributeNums.map(\n          num => attributes.filter(attr => attr.num === num)[0]\n        );\n        const foreignKeys = constraint.foreignKeyAttributeNums.map(\n          num => foreignAttributes.filter(attr => attr.num === num)[0]\n        );\n        if (!keys.every(_ => _) || !foreignKeys.every(_ => _)) {\n          throw new Error(\"Could not find key columns!\");\n        }\n        if (keys.some(key => omit(key, \"read\"))) {\n          return memo;\n        }\n        if (foreignKeys.some(key => omit(key, \"read\"))) {\n          return memo;\n        }\n        const isUnique = !!introspectionResultsByKind.constraint.find(\n          c =>\n            c.classId === table.id &&\n            (c.type === \"p\" || c.type === \"u\") &&\n            c.keyAttributeNums.length === keys.length &&\n            c.keyAttributeNums.every((n, i) => keys[i].num === n)\n        );\n\n        const isDeprecated = isUnique && legacyRelationMode === DEPRECATED;\n\n        const singleRelationFieldName = isUnique\n          ? inflection.singleRelationByKeysBackwards(\n              keys,\n              table,\n              foreignTable,\n              constraint\n            )\n          : null;\n\n        const primaryKeyConstraint = introspectionResultsByKind.constraint\n          .filter(con => con.classId === table.id)\n          .filter(con => con.type === \"p\")[0];\n        const primaryKeys =\n          primaryKeyConstraint &&\n          primaryKeyConstraint.keyAttributeNums.map(\n            num => attributes.filter(attr => attr.num === num)[0]\n          );\n\n        const shouldAddSingleRelation = isUnique && legacyRelationMode !== ONLY;\n\n        const shouldAddManyRelation =\n          !isUnique ||\n          legacyRelationMode === DEPRECATED ||\n          legacyRelationMode === ONLY;\n\n        if (\n          shouldAddSingleRelation &&\n          !omit(table, \"read\") &&\n          singleRelationFieldName\n        ) {\n          memo = extend(\n            memo,\n            {\n              [singleRelationFieldName]: fieldWithHooks(\n                singleRelationFieldName,\n                ({\n                  getDataFromParsedResolveInfoFragment,\n                  addDataGenerator,\n                }) => {\n                  addDataGenerator(parsedResolveInfoFragment => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(() => {\n                          const resolveData = getDataFromParsedResolveInfoFragment(\n                            parsedResolveInfoFragment,\n                            gqlTableType\n                          );\n                          const tableAlias = sql.identifier(Symbol());\n                          const foreignTableAlias = queryBuilder.getTableAlias();\n                          const query = queryFromResolveData(\n                            sql.identifier(schema.name, table.name),\n                            tableAlias,\n                            resolveData,\n                            {\n                              asJson: true,\n                              addNullCase: true,\n                              withPagination: false,\n                            },\n                            innerQueryBuilder => {\n                              innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                              keys.forEach((key, i) => {\n                                innerQueryBuilder.where(\n                                  sql.fragment`${tableAlias}.${sql.identifier(\n                                    key.name\n                                  )} = ${foreignTableAlias}.${sql.identifier(\n                                    foreignKeys[i].name\n                                  )}`\n                                );\n                              });\n                            }\n                          );\n                          return sql.fragment`(${query})`;\n                        }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                      },\n                    };\n                  });\n                  return {\n                    description:\n                      constraint.tags.backwardDescription ||\n                      `Reads a single \\`${tableTypeName}\\` that is related to this \\`${foreignTableTypeName}\\`.`,\n                    type: gqlTableType,\n                    args: {},\n                    resolve: (data, _args, _context, resolveInfo) => {\n                      const safeAlias = getSafeAliasFromResolveInfo(\n                        resolveInfo\n                      );\n                      return data[safeAlias];\n                    },\n                  };\n                },\n                {\n                  pgFieldIntrospection: table,\n                  isPgBackwardSingleRelationField: true,\n                }\n              ),\n            },\n            `Backward relation (single) for ${describePgEntity(\n              constraint\n            )}. To rename this relation with smart comments:\\n\\n  ${sqlCommentByAddingTags(\n              constraint,\n              {\n                foreignSingleFieldName: \"newNameHere\",\n              }\n            )}`\n          );\n        }\n        function makeFields(isConnection) {\n          if (isUnique && !isConnection) {\n            // Don't need this, use the singular instead\n            return;\n          }\n          if (shouldAddManyRelation && !omit(table, \"many\")) {\n            const manyRelationFieldName = isConnection\n              ? inflection.manyRelationByKeys(\n                  keys,\n                  table,\n                  foreignTable,\n                  constraint\n                )\n              : inflection.manyRelationByKeysSimple(\n                  keys,\n                  table,\n                  foreignTable,\n                  constraint\n                );\n\n            memo = extend(\n              memo,\n              {\n                [manyRelationFieldName]: fieldWithHooks(\n                  manyRelationFieldName,\n                  ({\n                    getDataFromParsedResolveInfoFragment,\n                    addDataGenerator,\n                  }) => {\n                    addDataGenerator(parsedResolveInfoFragment => {\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.select(() => {\n                            const resolveData = getDataFromParsedResolveInfoFragment(\n                              parsedResolveInfoFragment,\n                              isConnection ? ConnectionType : TableType\n                            );\n                            const tableAlias = sql.identifier(Symbol());\n                            const foreignTableAlias = queryBuilder.getTableAlias();\n                            const query = queryFromResolveData(\n                              sql.identifier(schema.name, table.name),\n                              tableAlias,\n                              resolveData,\n                              {\n                                withPagination: isConnection,\n                                withPaginationAsFields: false,\n                                asJsonAggregate: !isConnection,\n                              },\n                              innerQueryBuilder => {\n                                innerQueryBuilder.parentQueryBuilder = queryBuilder;\n                                if (primaryKeys) {\n                                  innerQueryBuilder.beforeLock(\n                                    \"orderBy\",\n                                    () => {\n                                      // append order by primary key to the list of orders\n                                      if (\n                                        !innerQueryBuilder.isOrderUnique(false)\n                                      ) {\n                                        innerQueryBuilder.data.cursorPrefix = [\n                                          \"primary_key_asc\",\n                                        ];\n                                        primaryKeys.forEach(key => {\n                                          innerQueryBuilder.orderBy(\n                                            sql.fragment`${innerQueryBuilder.getTableAlias()}.${sql.identifier(\n                                              key.name\n                                            )}`,\n                                            true\n                                          );\n                                        });\n                                        innerQueryBuilder.setOrderIsUnique();\n                                      }\n                                    }\n                                  );\n                                }\n\n                                keys.forEach((key, i) => {\n                                  innerQueryBuilder.where(\n                                    sql.fragment`${tableAlias}.${sql.identifier(\n                                      key.name\n                                    )} = ${foreignTableAlias}.${sql.identifier(\n                                      foreignKeys[i].name\n                                    )}`\n                                  );\n                                });\n                              }\n                            );\n                            return sql.fragment`(${query})`;\n                          }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n                        },\n                      };\n                    });\n                    const ConnectionType = getTypeByName(\n                      inflection.connection(gqlTableType.name)\n                    );\n                    const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                      table.type.id,\n                      null\n                    );\n                    return {\n                      description:\n                        constraint.tags.backwardDescription ||\n                        `Reads and enables pagination through a set of \\`${tableTypeName}\\`.`,\n                      type: isConnection\n                        ? new GraphQLNonNull(ConnectionType)\n                        : new GraphQLNonNull(\n                            new GraphQLList(new GraphQLNonNull(TableType))\n                          ),\n                      args: {},\n                      resolve: (data, _args, _context, resolveInfo) => {\n                        const safeAlias = getSafeAliasFromResolveInfo(\n                          resolveInfo\n                        );\n                        if (isConnection) {\n                          return addStartEndCursor(data[safeAlias]);\n                        } else {\n                          return data[safeAlias];\n                        }\n                      },\n                      deprecationReason: isDeprecated\n                        ? // $FlowFixMe\n                          `Please use ${singleRelationFieldName} instead`\n                        : undefined,\n                    };\n                  },\n                  {\n                    isPgFieldConnection: isConnection,\n                    isPgFieldSimpleCollection: !isConnection,\n                    isPgBackwardRelationField: true,\n                    pgFieldIntrospection: table,\n                  }\n                ),\n              },\n\n              `Backward relation (${\n                isConnection ? \"connection\" : \"simple collection\"\n              }) for ${describePgEntity(\n                constraint\n              )}. To rename this relation with smart comments:\\n\\n  ${sqlCommentByAddingTags(\n                constraint,\n                {\n                  [isConnection\n                    ? \"foreignFieldName\"\n                    : \"foreignSimpleFieldName\"]: \"newNameHere\",\n                }\n              )}`\n            );\n          }\n        }\n        if (hasConnections) {\n          makeFields(true);\n        }\n        if (hasSimpleCollections) {\n          makeFields(false);\n        }\n        return memo;\n      }, {}),\n      `Adding backward relations for ${Self.name}`\n    );\n  });\n}: Plugin);\n"]}