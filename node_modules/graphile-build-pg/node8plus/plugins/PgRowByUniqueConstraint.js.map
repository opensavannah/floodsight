{"version":3,"sources":["../../src/plugins/PgRowByUniqueConstraint.js"],"names":["debugSql","PgRowByUniqueConstraint","builder","hook","fields","build","context","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","gql2pg","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","scope","isRootQuery","fieldWithHooks","class","filter","table","namespace","reduce","memo","TableType","type","id","sqlFullTableName","identifier","name","uniqueConstraints","constraint","con","classId","attributes","attribute","attr","sort","a","b","num","forEach","keys","keyAttributeNums","map","find","some","key","every","_","Error","fieldName","rowByUniqueKeys","getDataFromParsedResolveInfoFragment","args","InputType","typeId","typeModifier","column","resolve","parent","pgClient","resolveInfo","parsedResolveInfoFragment","resolveData","query","undefined","queryBuilder","where","fragment","getTableAlias","text","values","compile","enabled","rows","row","isPgRowByUniqueConstraintField","pgFieldIntrospection"],"mappings":"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","file":"PgRowByUniqueConstraint.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\nconst debugSql = debugFactory(\"graphile-build-pg:sql\");\n\nexport default (async function PgRowByUniqueConstraint(builder) {\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      parseResolveInfo,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      gql2pg,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      graphql: { GraphQLNonNull },\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgOmit: omit,\n    } = build;\n    const {\n      scope: { isRootQuery },\n      fieldWithHooks,\n    } = context;\n    if (!isRootQuery) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.class\n        .filter(table => !!table.namespace)\n        .filter(table => !omit(table, \"read\"))\n        .reduce((memo, table) => {\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const sqlFullTableName = sql.identifier(\n            table.namespace.name,\n            table.name\n          );\n          if (TableType) {\n            const uniqueConstraints = introspectionResultsByKind.constraint\n              .filter(con => con.classId === table.id)\n              .filter(con => con.type === \"u\" || con.type === \"p\");\n            const attributes = introspectionResultsByKind.attribute\n              .filter(attr => attr.classId === table.id)\n              .sort((a, b) => a.num - b.num);\n            uniqueConstraints.forEach(constraint => {\n              if (omit(constraint, \"read\")) {\n                return;\n              }\n              const keys = constraint.keyAttributeNums.map(num =>\n                attributes.find(attr => attr.num === num)\n              );\n              if (keys.some(key => omit(key, \"read\"))) {\n                return;\n              }\n              if (!keys.every(_ => _)) {\n                throw new Error(\n                  \"Consistency error: could not find an attribute!\"\n                );\n              }\n              const fieldName = inflection.rowByUniqueKeys(\n                keys,\n                table,\n                constraint\n              );\n              memo[fieldName] = fieldWithHooks(\n                fieldName,\n                ({ getDataFromParsedResolveInfoFragment }) => {\n                  return {\n                    type: TableType,\n                    args: keys.reduce((memo, key) => {\n                      const InputType = pgGetGqlInputTypeByTypeIdAndModifier(\n                        key.typeId,\n                        key.typeModifier\n                      );\n                      if (!InputType) {\n                        throw new Error(\n                          `Could not find input type for key '${\n                            key.name\n                          }' on type '${TableType.name}'`\n                        );\n                      }\n                      memo[inflection.column(key)] = {\n                        type: new GraphQLNonNull(InputType),\n                      };\n                      return memo;\n                    }, {}),\n                    async resolve(parent, args, { pgClient }, resolveInfo) {\n                      const parsedResolveInfoFragment = parseResolveInfo(\n                        resolveInfo\n                      );\n                      const resolveData = getDataFromParsedResolveInfoFragment(\n                        parsedResolveInfoFragment,\n                        TableType\n                      );\n                      const query = queryFromResolveData(\n                        sqlFullTableName,\n                        undefined,\n                        resolveData,\n                        {},\n                        queryBuilder => {\n                          keys.forEach(key => {\n                            queryBuilder.where(\n                              sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                key.name\n                              )} = ${gql2pg(\n                                args[inflection.column(key)],\n                                key.type,\n                                key.typeModifier\n                              )}`\n                            );\n                          });\n                        }\n                      );\n                      const { text, values } = sql.compile(query);\n                      if (debugSql.enabled) debugSql(text);\n                      const {\n                        rows: [row],\n                      } = await pgClient.query(text, values);\n                      return row;\n                    },\n                  };\n                },\n                {\n                  isPgRowByUniqueConstraintField: true,\n                  pgFieldIntrospection: constraint,\n                }\n              );\n            });\n          }\n          return memo;\n        }, {}),\n      `Adding \"row by unique constraint\" fields to root Query type`\n    );\n  });\n}: Plugin);\n"]}