{"version":3,"sources":["../../src/plugins/PgColumnsPlugin.js"],"names":["nullableIf","GraphQLNonNull","condition","Type","PgColumnsPlugin","builder","hook","build","pgSql","sql","pgTweakFragmentForTypeAndModifier","pgQueryFromResolveData","queryFromResolveData","getSelectValueForFieldAndTypeAndModifier","ReturnType","fieldScope","parsedResolveInfoFragment","sqlFullName","type","typeModifier","getDataFromParsedResolveInfoFragment","isPgArray","ident","identifier","Symbol","fragment","arrayItemType","resolveData","jsonBuildObject","onlyJsonField","addNullCase","extend","pgGetSelectValueForFieldAndTypeAndModifier","fields","context","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pg2gql","graphql","GraphQLString","pgColumnFilter","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","scope","isPgRowType","isPgCompoundType","pgIntrospection","table","fieldWithHooks","kind","attribute","filter","attr","classId","id","reduce","memo","fieldName","column","Error","namespaceName","name","fieldContext","addDataGenerator","typeId","pgQuery","queryBuilder","select","getTableAlias","description","isNotNull","domainIsNotNull","resolve","data","_args","_context","_resolveInfo","pgFieldIntrospection","pgGetGqlInputTypeByTypeIdAndModifier","isPgPatch","isPgBaseInput","pgAddSubfield","identity","hasDefault"],"mappings":"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","file":"PgColumnsPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nexport default (function PgColumnsPlugin(builder) {\n  builder.hook(\"build\", build => {\n    const {\n      pgSql: sql,\n      pgTweakFragmentForTypeAndModifier,\n      pgQueryFromResolveData: queryFromResolveData,\n    } = build;\n    const getSelectValueForFieldAndTypeAndModifier = (\n      ReturnType,\n      fieldScope,\n      parsedResolveInfoFragment,\n      sqlFullName,\n      type,\n      typeModifier\n    ) => {\n      const { getDataFromParsedResolveInfoFragment } = fieldScope;\n      if (type.isPgArray) {\n        const ident = sql.identifier(Symbol());\n        return sql.fragment`\n          (\n            case\n            when ${sqlFullName} is null then null\n            when coalesce(array_length(${sqlFullName}, 1), 0) = 0 then '[]'::json\n            else\n              (\n                select json_agg(${getSelectValueForFieldAndTypeAndModifier(\n                  ReturnType,\n                  fieldScope,\n                  parsedResolveInfoFragment,\n                  ident,\n                  type.arrayItemType,\n                  typeModifier\n                )})\n                from unnest(${sqlFullName}) as ${ident}\n              )\n            end\n          )\n        `;\n      } else {\n        const resolveData = getDataFromParsedResolveInfoFragment(\n          parsedResolveInfoFragment,\n          ReturnType\n        );\n        if (type.type === \"c\") {\n          const jsonBuildObject = queryFromResolveData(\n            sql.identifier(Symbol()), // Ignore!\n            sqlFullName,\n            resolveData,\n            { onlyJsonField: true, addNullCase: true }\n          );\n          return jsonBuildObject;\n        } else {\n          return pgTweakFragmentForTypeAndModifier(\n            sqlFullName,\n            type,\n            typeModifier,\n            resolveData\n          );\n        }\n      }\n    };\n    return build.extend(build, {\n      pgGetSelectValueForFieldAndTypeAndModifier: getSelectValueForFieldAndTypeAndModifier,\n    });\n  });\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      pg2gql,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgColumnFilter,\n      inflection,\n      pgOmit: omit,\n      pgGetSelectValueForFieldAndTypeAndModifier: getSelectValueForFieldAndTypeAndModifier,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const {\n      scope: { isPgRowType, isPgCompoundType, pgIntrospection: table },\n      fieldWithHooks,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .filter(attr => !omit(attr, \"read\"))\n        .reduce((memo, attr) => {\n          /*\n            attr =\n              { kind: 'attribute',\n                classId: '6546809',\n                num: 21,\n                name: 'upstreamName',\n                description: null,\n                typeId: '6484393',\n                isNotNull: false,\n                hasDefault: false }\n            */\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo = extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                fieldContext => {\n                  const { addDataGenerator } = fieldContext;\n                  const ReturnType =\n                    pgGetGqlTypeByTypeIdAndModifier(\n                      attr.typeId,\n                      attr.typeModifier\n                    ) || GraphQLString;\n                  addDataGenerator(parsedResolveInfoFragment => {\n                    return {\n                      pgQuery: queryBuilder => {\n                        queryBuilder.select(\n                          getSelectValueForFieldAndTypeAndModifier(\n                            ReturnType,\n                            fieldContext,\n                            parsedResolveInfoFragment,\n                            sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(\n                              attr.name\n                            )})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING\n                            attr.type,\n                            attr.typeModifier\n                          ),\n                          fieldName\n                        );\n                      },\n                    };\n                  });\n                  return {\n                    description: attr.description,\n                    type: nullableIf(\n                      GraphQLNonNull,\n                      !attr.isNotNull && !attr.type.domainIsNotNull,\n                      ReturnType\n                    ),\n                    resolve: (data, _args, _context, _resolveInfo) => {\n                      return pg2gql(data[fieldName], attr.type);\n                    },\n                  };\n                },\n                { pgFieldIntrospection: attr }\n              ),\n            },\n            `Adding field for ${describePgEntity(\n              attr\n            )}. You can rename this field with:\\n\\n  ${sqlCommentByAddingTags(\n              attr,\n              {\n                name: \"newNameHere\",\n              }\n            )}`\n          );\n          return memo;\n        }, {}),\n      `Adding columns to '${describePgEntity(table)}'`\n    );\n  });\n  builder.hook(\"GraphQLInputObjectType:fields\", (fields, build, context) => {\n    const {\n      extend,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      graphql: { GraphQLString, GraphQLNonNull },\n      pgColumnFilter,\n      inflection,\n      pgOmit: omit,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const {\n      scope: {\n        isPgRowType,\n        isPgCompoundType,\n        isPgPatch,\n        isPgBaseInput,\n        pgIntrospection: table,\n        pgAddSubfield,\n      },\n      fieldWithHooks,\n    } = context;\n    if (\n      !(isPgRowType || isPgCompoundType) ||\n      !table ||\n      table.kind !== \"class\"\n    ) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .filter(\n          attr =>\n            !omit(\n              attr,\n              isPgBaseInput ? \"base\" : isPgPatch ? \"update\" : \"create\"\n            )\n        )\n        .filter(attr => attr.identity !== \"a\")\n        .reduce((memo, attr) => {\n          const fieldName = inflection.column(attr);\n          if (memo[fieldName]) {\n            throw new Error(\n              `Two columns produce the same GraphQL field name '${fieldName}' on input class '${\n                table.namespaceName\n              }.${table.name}'; one of them is '${attr.name}'`\n            );\n          }\n          memo = extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                pgAddSubfield(\n                  fieldName,\n                  attr.name,\n                  attr.type,\n                  {\n                    description: attr.description,\n                    type: nullableIf(\n                      GraphQLNonNull,\n                      isPgBaseInput ||\n                        isPgPatch ||\n                        (!attr.isNotNull && !attr.type.domainIsNotNull) ||\n                        attr.hasDefault ||\n                        attr.identity === \"d\",\n                      pgGetGqlInputTypeByTypeIdAndModifier(\n                        attr.typeId,\n                        attr.typeModifier\n                      ) || GraphQLString\n                    ),\n                  },\n                  attr.typeModifier\n                ),\n                { pgFieldIntrospection: attr }\n              ),\n            },\n            `Adding input object field for ${describePgEntity(\n              attr\n            )}. You can rename this field with:\\n\\n  ${sqlCommentByAddingTags(\n              attr,\n              {\n                name: \"newNameHere\",\n              }\n            )}`\n          );\n          return memo;\n        }, {}),\n      `Adding columns to input object for ${describePgEntity(table)}`\n    );\n  });\n}: Plugin);\n"]}