{"version":3,"sources":["../../src/plugins/PgMutationUpdateDeletePlugin.js"],"names":["debug","base64Decode","str","Buffer","from","String","toString","PgMutationUpdateDeletePlugin","builder","pgDisableDefaultMutations","hook","fields","build","context","newWithHooks","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","fieldDataGeneratorsByType","extend","parseResolveInfo","getTypeByName","gql2pg","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","getNodeType","graphql","GraphQLNonNull","GraphQLInputObjectType","GraphQLString","GraphQLObjectType","GraphQLID","pgColumnFilter","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","pgViaTemporaryTable","viaTemporaryTable","describePgEntity","sqlCommentByAddingTags","scope","isRootMutation","fieldWithHooks","pluralize","singularize","camelCase","reduce","outerMemo","mode","class","filter","table","namespace","isUpdatable","isDeletable","memo","TableType","type","id","commonCodeRenameMe","pgClient","resolveInfo","getDataFromParsedResolveInfoFragment","PayloadType","input","condition","parsedResolveInfoFragment","resolveData","sqlTypeIdentifier","identifier","name","sqlMutationQuery","sqlColumns","sqlValues","inputData","patchField","tableFieldName","attribute","attr","classId","forEach","fieldName","column","val","push","typeModifier","length","query","join","map","col","i","fragment","modifiedRowAlias","Symbol","row","rows","e","Error","clientMutationId","data","uniqueConstraints","constraint","con","attributes","sort","a","b","num","Table","tableTypeName","TablePatch","patchType","description","recurseDataGeneratorsForField","tableName","deletedNodeIdFieldName","Object","assign","resolve","addDataGenerator","fieldDataGeneratorsByTableType","get","gens","gen","__identifiers","isPgMutationPayloadDeletedNodeIdField","__origin","isMutationPayload","isPgUpdatePayloadType","isPgDeletePayloadType","pgIntrospection","primaryKeyConstraint","primaryKeys","keyAttributeNums","find","InputType","isPgUpdateInputType","isPgUpdateNodeInputType","isPgDeleteInputType","isPgDeleteNodeInputType","pgInflection","isMutationInput","args","parent","nodeId","alias","identifiers","JSON","parse","NodeTypeByAlias","key","idx","isPgNodeMutation","pgFieldIntrospection","keys","every","_","some","typeId","isPgUpdateByKeysInputType","isPgDeleteByKeysInputType","pgKeys"],"mappings":"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","file":"PgMutationUpdateDeletePlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\nconst base64Decode = str => Buffer.from(String(str), \"base64\").toString(\"utf8\");\n\nexport default (async function PgMutationUpdateDeletePlugin(\n  builder,\n  { pgDisableDefaultMutations }\n) {\n  if (pgDisableDefaultMutations) {\n    return;\n  }\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      newWithHooks,\n      getNodeIdForTypeAndIdentifiers,\n      nodeIdFieldName,\n      fieldDataGeneratorsByType,\n      extend,\n      parseResolveInfo,\n      getTypeByName,\n      gql2pg,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      getNodeType,\n      graphql: {\n        GraphQLNonNull,\n        GraphQLInputObjectType,\n        GraphQLString,\n        GraphQLObjectType,\n        GraphQLID,\n      },\n      pgColumnFilter,\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgOmit: omit,\n      pgViaTemporaryTable: viaTemporaryTable,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const {\n      scope: { isRootMutation },\n      fieldWithHooks,\n    } = context;\n    const { pluralize, singularize, camelCase } = inflection;\n    if (!isRootMutation) {\n      return fields;\n    }\n    return extend(\n      fields,\n      [\"update\", \"delete\"].reduce(\n        (outerMemo, mode) =>\n          introspectionResultsByKind.class\n            .filter(table => !!table.namespace)\n            .filter(\n              table =>\n                (mode === \"update\" &&\n                  table.isUpdatable &&\n                  !omit(table, \"update\")) ||\n                (mode === \"delete\" &&\n                  table.isDeletable &&\n                  !omit(table, \"delete\"))\n            )\n            .reduce((memo, table) => {\n              const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                table.type.id,\n                null\n              );\n              if (!TableType) {\n                return memo;\n              }\n              async function commonCodeRenameMe(\n                pgClient,\n                resolveInfo,\n                getDataFromParsedResolveInfoFragment,\n                PayloadType,\n                input,\n                condition,\n                context\n              ) {\n                const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n                const resolveData = getDataFromParsedResolveInfoFragment(\n                  parsedResolveInfoFragment,\n                  PayloadType\n                );\n\n                const sqlTypeIdentifier = sql.identifier(\n                  table.namespace.name,\n                  table.name\n                );\n\n                let sqlMutationQuery;\n                if (mode === \"update\") {\n                  const sqlColumns = [];\n                  const sqlValues = [];\n                  const inputData =\n                    input[\n                      inflection.patchField(inflection.tableFieldName(table))\n                    ];\n                  introspectionResultsByKind.attribute\n                    .filter(attr => attr.classId === table.id)\n                    .filter(attr => pgColumnFilter(attr, build, context))\n                    .filter(attr => !omit(attr, \"update\"))\n                    .forEach(attr => {\n                      const fieldName = inflection.column(attr);\n                      if (\n                        fieldName in inputData /* Because we care about null! */\n                      ) {\n                        const val = inputData[fieldName];\n                        sqlColumns.push(sql.identifier(attr.name));\n                        sqlValues.push(\n                          gql2pg(val, attr.type, attr.typeModifier)\n                        );\n                      }\n                    });\n                  if (sqlColumns.length === 0) {\n                    return null;\n                  }\n                  sqlMutationQuery = sql.query`\n                      update ${sql.identifier(\n                        table.namespace.name,\n                        table.name\n                      )} set ${sql.join(\n                    sqlColumns.map(\n                      (col, i) => sql.fragment`${col} = ${sqlValues[i]}`\n                    ),\n                    \", \"\n                  )}\n                      where ${condition}\n                      returning *`;\n                } else {\n                  sqlMutationQuery = sql.query`\n                      delete from ${sql.identifier(\n                        table.namespace.name,\n                        table.name\n                      )}\n                      where ${condition}\n                      returning *`;\n                }\n\n                const modifiedRowAlias = sql.identifier(Symbol());\n                const query = queryFromResolveData(\n                  modifiedRowAlias,\n                  modifiedRowAlias,\n                  resolveData,\n                  {}\n                );\n                let row;\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  const rows = await viaTemporaryTable(\n                    pgClient,\n                    sqlTypeIdentifier,\n                    sqlMutationQuery,\n                    modifiedRowAlias,\n                    query\n                  );\n                  row = rows[0];\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n                if (!row) {\n                  throw new Error(\n                    `No values were ${mode}d in collection '${pluralize(\n                      table.name\n                    )}' because no values were found.`\n                  );\n                }\n                return {\n                  clientMutationId: input.clientMutationId,\n                  data: row,\n                };\n              }\n              if (TableType) {\n                const uniqueConstraints = introspectionResultsByKind.constraint\n                  .filter(con => con.classId === table.id)\n                  .filter(con => con.type === \"u\" || con.type === \"p\");\n                const attributes = introspectionResultsByKind.attribute\n                  .filter(attr => attr.classId === table.id)\n                  .sort((a, b) => a.num - b.num);\n                const Table = pgGetGqlTypeByTypeIdAndModifier(\n                  table.type.id,\n                  null\n                );\n                const tableTypeName = Table.name;\n                const TablePatch = getTypeByName(\n                  inflection.patchType(Table.name)\n                );\n                const PayloadType = newWithHooks(\n                  GraphQLObjectType,\n                  {\n                    name: inflection[\n                      mode === \"delete\"\n                        ? \"deletePayloadType\"\n                        : \"updatePayloadType\"\n                    ](table),\n                    description: `The output of our ${mode} \\`${tableTypeName}\\` mutation.`,\n                    fields: ({\n                      recurseDataGeneratorsForField,\n                      fieldWithHooks,\n                    }) => {\n                      const tableName = inflection.tableFieldName(table);\n                      recurseDataGeneratorsForField(tableName);\n                      // This should really be `-node-id` but for compatibility with PostGraphQL v3 we haven't made that change.\n                      const deletedNodeIdFieldName = camelCase(\n                        `deleted-${singularize(table.name)}-id`\n                      );\n                      return Object.assign(\n                        {\n                          clientMutationId: {\n                            description:\n                              \"The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.\",\n                            type: GraphQLString,\n                          },\n                          [tableName]: {\n                            description: `The \\`${tableTypeName}\\` that was ${mode}d by this mutation.`,\n                            type: Table,\n                            resolve(data) {\n                              return data.data;\n                            },\n                          },\n                        },\n                        mode === \"delete\"\n                          ? {\n                              [deletedNodeIdFieldName]: fieldWithHooks(\n                                deletedNodeIdFieldName,\n                                ({ addDataGenerator }) => {\n                                  const fieldDataGeneratorsByTableType = fieldDataGeneratorsByType.get(\n                                    TableType\n                                  );\n\n                                  const gens =\n                                    fieldDataGeneratorsByTableType &&\n                                    fieldDataGeneratorsByTableType[\n                                      nodeIdFieldName\n                                    ];\n                                  if (gens) {\n                                    gens.forEach(gen => addDataGenerator(gen));\n                                  }\n                                  return {\n                                    type: GraphQLID,\n                                    resolve(data) {\n                                      return (\n                                        data.data.__identifiers &&\n                                        getNodeIdForTypeAndIdentifiers(\n                                          Table,\n                                          ...data.data.__identifiers\n                                        )\n                                      );\n                                    },\n                                  };\n                                },\n                                {\n                                  isPgMutationPayloadDeletedNodeIdField: true,\n                                }\n                              ),\n                            }\n                          : null\n                      );\n                    },\n                  },\n                  {\n                    __origin: `Adding table ${mode} mutation payload type for ${describePgEntity(\n                      table\n                    )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                      table,\n                      {\n                        name: \"newNameHere\",\n                      }\n                    )}`,\n                    isMutationPayload: true,\n                    isPgUpdatePayloadType: mode === \"update\",\n                    isPgDeletePayloadType: mode === \"delete\",\n                    pgIntrospection: table,\n                  }\n                );\n\n                // NodeId\n                const primaryKeyConstraint = introspectionResultsByKind.constraint\n                  .filter(con => con.classId === table.id)\n                  .filter(con => con.type === \"p\")[0];\n                if (nodeIdFieldName && primaryKeyConstraint) {\n                  const primaryKeys =\n                    primaryKeyConstraint &&\n                    primaryKeyConstraint.keyAttributeNums.map(num =>\n                      attributes.find(attr => attr.num === num)\n                    );\n                  const fieldName = inflection[\n                    mode === \"update\" ? \"updateNode\" : \"deleteNode\"\n                  ](table);\n                  const InputType = newWithHooks(\n                    GraphQLInputObjectType,\n                    {\n                      description: `All input for the \\`${fieldName}\\` mutation.`,\n                      name: inflection[\n                        mode === \"update\"\n                          ? \"updateNodeInputType\"\n                          : \"deleteNodeInputType\"\n                      ](table),\n                      fields: Object.assign(\n                        {\n                          clientMutationId: {\n                            description:\n                              \"An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.\",\n                            type: GraphQLString,\n                          },\n                          [nodeIdFieldName]: {\n                            description: `The globally unique \\`ID\\` which will identify a single \\`${tableTypeName}\\` to be ${mode}d.`,\n                            type: new GraphQLNonNull(GraphQLID),\n                          },\n                        },\n                        mode === \"update\"\n                          ? {\n                              [inflection.patchField(\n                                inflection.tableFieldName(table)\n                              )]: {\n                                description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                type: new GraphQLNonNull(TablePatch),\n                              },\n                            }\n                          : null\n                      ),\n                    },\n                    {\n                      __origin: `Adding table ${mode} (by node ID) mutation input type for ${describePgEntity(\n                        table\n                      )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                        table,\n                        {\n                          name: \"newNameHere\",\n                        }\n                      )}`,\n                      isPgUpdateInputType: mode === \"update\",\n                      isPgUpdateNodeInputType: mode === \"update\",\n                      isPgDeleteInputType: mode === \"delete\",\n                      isPgDeleteNodeInputType: mode === \"delete\",\n                      pgInflection: table,\n                      isMutationInput: true,\n                    }\n                  );\n\n                  memo = extend(\n                    memo,\n                    {\n                      [fieldName]: fieldWithHooks(\n                        fieldName,\n                        context => {\n                          const {\n                            getDataFromParsedResolveInfoFragment,\n                          } = context;\n                          return {\n                            description:\n                              mode === \"update\"\n                                ? `Updates a single \\`${tableTypeName}\\` using its globally unique id and a patch.`\n                                : `Deletes a single \\`${tableTypeName}\\` using its globally unique id.`,\n                            type: PayloadType,\n                            args: {\n                              input: {\n                                type: new GraphQLNonNull(InputType),\n                              },\n                            },\n                            async resolve(\n                              parent,\n                              { input },\n                              { pgClient },\n                              resolveInfo\n                            ) {\n                              const nodeId = input[nodeIdFieldName];\n                              try {\n                                const [alias, ...identifiers] = JSON.parse(\n                                  base64Decode(nodeId)\n                                );\n                                const NodeTypeByAlias = getNodeType(alias);\n                                if (NodeTypeByAlias !== TableType) {\n                                  throw new Error(\"Mismatched type\");\n                                }\n                                if (identifiers.length !== primaryKeys.length) {\n                                  throw new Error(\"Invalid ID\");\n                                }\n\n                                return commonCodeRenameMe(\n                                  pgClient,\n                                  resolveInfo,\n                                  getDataFromParsedResolveInfoFragment,\n                                  PayloadType,\n                                  input,\n                                  sql.fragment`(${sql.join(\n                                    primaryKeys.map(\n                                      (key, idx) =>\n                                        sql.fragment`${sql.identifier(\n                                          key.name\n                                        )} = ${gql2pg(\n                                          identifiers[idx],\n                                          key.type,\n                                          key.typeModifier\n                                        )}`\n                                    ),\n                                    \") and (\"\n                                  )})`,\n                                  context\n                                );\n                              } catch (e) {\n                                debug(e);\n                                return null;\n                              }\n                            },\n                          };\n                        },\n                        {\n                          isPgNodeMutation: true,\n                          pgFieldIntrospection: table,\n                          [mode === \"update\"\n                            ? \"isPgUpdateMutationField\"\n                            : \"isPgDeleteMutationField\"]: true,\n                        }\n                      ),\n                    },\n                    \"Adding ${mode} mutation for ${describePgEntity(table)}\"\n                  );\n                }\n\n                // Unique\n                uniqueConstraints.forEach(constraint => {\n                  if (omit(constraint, mode)) {\n                    return;\n                  }\n                  const keys = constraint.keyAttributeNums.map(num =>\n                    attributes.find(attr => attr.num === num)\n                  );\n                  if (!keys.every(_ => _)) {\n                    throw new Error(\n                      \"Consistency error: could not find an attribute!\"\n                    );\n                  }\n                  if (keys.some(key => omit(key, \"read\"))) {\n                    return;\n                  }\n                  const fieldName = inflection[\n                    mode === \"update\" ? \"updateByKeys\" : \"deleteByKeys\"\n                  ](keys, table, constraint);\n                  const InputType = newWithHooks(\n                    GraphQLInputObjectType,\n                    {\n                      description: `All input for the \\`${fieldName}\\` mutation.`,\n                      name: inflection[\n                        mode === \"update\"\n                          ? \"updateByKeysInputType\"\n                          : \"deleteByKeysInputType\"\n                      ](keys, table, constraint),\n                      fields: Object.assign(\n                        {\n                          clientMutationId: {\n                            type: GraphQLString,\n                          },\n                        },\n                        mode === \"update\"\n                          ? {\n                              [inflection.patchField(\n                                inflection.tableFieldName(table)\n                              )]: {\n                                description: `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                type: new GraphQLNonNull(TablePatch),\n                              },\n                            }\n                          : null,\n                        keys.reduce((memo, key) => {\n                          memo[inflection.column(key)] = {\n                            description: key.description,\n                            type: new GraphQLNonNull(\n                              pgGetGqlInputTypeByTypeIdAndModifier(\n                                key.typeId,\n                                key.typeModifier\n                              )\n                            ),\n                          };\n                          return memo;\n                        }, {})\n                      ),\n                    },\n                    {\n                      __origin: `Adding table ${mode} mutation input type for ${describePgEntity(\n                        constraint\n                      )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                        table,\n                        {\n                          name: \"newNameHere\",\n                        }\n                      )}`,\n                      isPgUpdateInputType: mode === \"update\",\n                      isPgUpdateByKeysInputType: mode === \"update\",\n                      isPgDeleteInputType: mode === \"delete\",\n                      isPgDeleteByKeysInputType: mode === \"delete\",\n                      pgInflection: table,\n                      pgKeys: keys,\n                      isMutationInput: true,\n                    }\n                  );\n\n                  memo = extend(\n                    memo,\n                    {\n                      [fieldName]: fieldWithHooks(\n                        fieldName,\n                        context => {\n                          const {\n                            getDataFromParsedResolveInfoFragment,\n                          } = context;\n                          return {\n                            description:\n                              mode === \"update\"\n                                ? `Updates a single \\`${tableTypeName}\\` using a unique key and a patch.`\n                                : `Deletes a single \\`${tableTypeName}\\` using a unique key.`,\n                            type: PayloadType,\n                            args: {\n                              input: {\n                                type: new GraphQLNonNull(InputType),\n                              },\n                            },\n                            async resolve(\n                              parent,\n                              { input },\n                              { pgClient },\n                              resolveInfo\n                            ) {\n                              return commonCodeRenameMe(\n                                pgClient,\n                                resolveInfo,\n                                getDataFromParsedResolveInfoFragment,\n                                PayloadType,\n                                input,\n                                sql.fragment`(${sql.join(\n                                  keys.map(\n                                    key =>\n                                      sql.fragment`${sql.identifier(\n                                        key.name\n                                      )} = ${gql2pg(\n                                        input[inflection.column(key)],\n                                        key.type,\n                                        key.typeModifier\n                                      )}`\n                                  ),\n                                  \") and (\"\n                                )})`,\n                                context\n                              );\n                            },\n                          };\n                        },\n                        {\n                          isPgNodeMutation: false,\n                          pgFieldIntrospection: table,\n                          [mode === \"update\"\n                            ? \"isPgUpdateMutationField\"\n                            : \"isPgDeleteMutationField\"]: true,\n                        }\n                      ),\n                    },\n                    `Adding ${mode} mutation for ${describePgEntity(\n                      constraint\n                    )}`\n                  );\n                });\n              }\n              return memo;\n            }, outerMemo),\n        {}\n      ),\n      `Adding default update/delete mutations to root Mutation type`\n    );\n  });\n}: Plugin);\n"]}