{"version":3,"sources":["../../src/plugins/PgConnectionArgCondition.js"],"names":["PgConnectionArgCondition","builder","hook","_","build","newWithHooks","pgIntrospectionResultsByKind","introspectionResultsByKind","pgGetGqlInputTypeByTypeIdAndModifier","graphql","GraphQLInputObjectType","GraphQLString","pgColumnFilter","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","class","filter","table","isSelectable","namespace","forEach","tableTypeName","tableType","description","name","conditionType","fields","context","fieldWithHooks","attribute","attr","classId","id","reduce","memo","fieldName","column","extend","type","typeId","typeModifier","isPgConnectionConditionInputField","__origin","pgIntrospection","isPgCondition","args","pgSql","sql","gql2pg","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","scope","isPgFieldConnection","isPgFieldSimpleCollection","pgFieldIntrospection","addArgDataGenerator","Self","field","shouldAddCondition","kind","TableType","TableConditionType","relevantAttributes","connectionCondition","condition","pgQuery","queryBuilder","val","where","fragment","getTableAlias","identifier"],"mappings":";;;;;;kBAGgB,SAASA,wBAAT,CAAkCC,OAAlC,EAA2C;AACzDA,UAAQC,IAAR,CAAa,MAAb,EAAqB,CAACC,CAAD,EAAIC,KAAJ,KAAc;AACjC,UAAM;AACJC,kBADI;AAEJC,oCAA8BC,0BAF1B;AAGJC,0CAHI;AAIJC,eAAS,EAAEC,sBAAF,EAA0BC,aAA1B,EAJL;AAKJC,oBALI;AAMJC,gBANI;AAOJC,cAAQC,IAPJ;AAQJC,sBARI;AASJC;AATI,QAUFb,KAVJ;AAWAG,+BAA2BW,KAA3B,CACGC,MADH,CACUC,SAASA,MAAMC,YAAN,IAAsB,CAACN,KAAKK,KAAL,EAAY,QAAZ,CAD1C,EAEGD,MAFH,CAEUC,SAAS,CAAC,CAACA,MAAME,SAF3B,EAGGC,OAHH,CAGWH,SAAS;AAChB,YAAMI,gBAAgBX,WAAWY,SAAX,CAAqBL,KAArB,CAAtB;AACA;AACAf,mBACEK,sBADF,EAEE;AACEgB,qBAAc,oCAAmCF,aAAc,wFADjE;AAEEG,cAAMd,WAAWe,aAAX,CAAyBf,WAAWY,SAAX,CAAqBL,KAArB,CAAzB,CAFR;AAGES,gBAAQC,WAAW;AACjB,gBAAM,EAAEC,cAAF,KAAqBD,OAA3B;AACA,iBAAOvB,2BAA2ByB,SAA3B,CACJb,MADI,CACGc,QAAQA,KAAKC,OAAL,KAAiBd,MAAMe,EADlC,EAEJhB,MAFI,CAEGc,QAAQrB,eAAeqB,IAAf,EAAqB7B,KAArB,EAA4B0B,OAA5B,CAFX,EAGJX,MAHI,CAGGc,QAAQ,CAAClB,KAAKkB,IAAL,EAAW,QAAX,CAHZ,EAIJG,MAJI,CAIG,CAACC,IAAD,EAAOJ,IAAP,KAAgB;AACtB,kBAAMK,YAAYzB,WAAW0B,MAAX,CAAkBN,IAAlB,CAAlB;AACAI,mBAAOjC,MAAMoC,MAAN,CACLH,IADK,EAEL;AACE,eAACC,SAAD,GAAaP,eACXO,SADW,EAEX;AACEZ,6BAAc,2CAA0CY,SAAU,WADpE;AAEEG,sBACEjC,qCACEyB,KAAKS,MADP,EAEET,KAAKU,YAFP,KAGKhC;AANT,eAFW,EAUX;AACEiC,mDAAmC;AADrC,eAVW;AADf,aAFK,EAkBJ,iCAAgC5B,iBAAiBiB,IAAjB,CAAuB,EAlBnD,CAAP;AAoBA,mBAAOI,IAAP;AACD,WA3BI,EA2BF,EA3BE,CAAP;AA4BD;AAjCH,OAFF,EAqCE;AACEQ,kBAAW,6BAA4B7B,iBACrCI,KADqC,CAErC,uDAAsDH,uBACtDG,KADsD,EAEtD;AACEO,gBAAM;AADR,SAFsD,CAKtD,EARJ;AASEmB,yBAAiB1B,KATnB;AAUE2B,uBAAe;AAVjB,OArCF;AAkDD,KAxDH;AAyDA,WAAO5C,CAAP;AACD,GAtED;AAuEAF,UAAQC,IAAR,CACE,qCADF,EAEE,CAAC8C,IAAD,EAAO5C,KAAP,EAAc0B,OAAd,KAA0B;AACxB,UAAM;AACJmB,aAAOC,GADH;AAEJC,YAFI;AAGJX,YAHI;AAIJY,mBAJI;AAKJC,qCALI;AAMJ/C,oCAA8BC,0BAN1B;AAOJK,oBAPI;AAQJC,gBARI;AASJC,cAAQC;AATJ,QAUFX,KAVJ;AAWA,UAAM;AACJkD,aAAO;AACLC,2BADK;AAELC,iCAFK;AAGLC,8BAAsBrC;AAHjB,OADH;AAMJsC,yBANI;AAOJC,UAPI;AAQJC;AARI,QASF9B,OATJ;AAUA,UAAM+B,qBACJN,uBAAuBC,yBADzB;AAEA,QACE,CAACK,kBAAD,IACA,CAACzC,KADD,IAEAA,MAAM0C,IAAN,KAAe,OAFf,IAGA,CAAC1C,MAAME,SAHP,IAIAP,KAAKK,KAAL,EAAY,QAAZ,CALF,EAME;AACA,aAAO4B,IAAP;AACD;AACD,UAAMe,YAAYV,gCAAgCjC,MAAMqB,IAAN,CAAWN,EAA3C,EAA+C,IAA/C,CAAlB;AACA,UAAM6B,qBAAqBZ,cACzBvC,WAAWe,aAAX,CAAyBmC,UAAUpC,IAAnC,CADyB,CAA3B;;AAIA,UAAMsC,qBAAqB1D,2BAA2ByB,SAA3B,CACxBb,MADwB,CACjBc,QAAQA,KAAKC,OAAL,KAAiBd,MAAMe,EADd,EAExBhB,MAFwB,CAEjBc,QAAQrB,eAAeqB,IAAf,EAAqB7B,KAArB,EAA4B0B,OAA5B,CAFS,EAGxBX,MAHwB,CAGjBc,QAAQ,CAAClB,KAAKkB,IAAL,EAAW,QAAX,CAHQ,CAA3B;;AAKAyB,wBAAoB,SAASQ,mBAAT,CAA6B,EAAEC,SAAF,EAA7B,EAA4C;AAC9D,aAAO;AACLC,iBAASC,gBAAgB;AACvB,cAAIF,aAAa,IAAjB,EAAuB;AACrBF,+BAAmB1C,OAAnB,CAA2BU,QAAQ;AACjC,oBAAMK,YAAYzB,WAAW0B,MAAX,CAAkBN,IAAlB,CAAlB;AACA,oBAAMqC,MAAMH,UAAU7B,SAAV,CAAZ;AACA,kBAAIgC,OAAO,IAAX,EAAiB;AACfD,6BAAaE,KAAb,CACErB,IAAIsB,QAAS,GAAEH,aAAaI,aAAb,EAA6B,IAAGvB,IAAIwB,UAAJ,CAC7CzC,KAAKN,IADwC,CAE7C,MAAKwB,OAAOmB,GAAP,EAAYrC,KAAKQ,IAAjB,EAAuBR,KAAKU,YAA5B,CAA0C,EAHnD;AAKD,eAND,MAMO,IAAI2B,QAAQ,IAAZ,EAAkB;AACvBD,6BAAaE,KAAb,CACErB,IAAIsB,QAAS,GAAEH,aAAaI,aAAb,EAA6B,IAAGvB,IAAIwB,UAAJ,CAC7CzC,KAAKN,IADwC,CAE7C,UAHJ;AAKD;AACF,aAhBD;AAiBD;AACF;AArBI,OAAP;AAuBD,KAxBD;;AA0BA,WAAOa,OACLQ,IADK,EAEL;AACEmB,iBAAW;AACTzC,qBACE,0FAFO;AAGTe,cAAMuB;AAHG;AADb,KAFK,EASJ,yCAAwCJ,MAAMjC,IAAK,SAAQgC,KAAKhC,IAAK,GATjE,CAAP;AAWD,GAlFH;AAoFD,C","file":"PgConnectionArgCondition.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nexport default (function PgConnectionArgCondition(builder) {\n  builder.hook(\"init\", (_, build) => {\n    const {\n      newWithHooks,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgGetGqlInputTypeByTypeIdAndModifier,\n      graphql: { GraphQLInputObjectType, GraphQLString },\n      pgColumnFilter,\n      inflection,\n      pgOmit: omit,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    introspectionResultsByKind.class\n      .filter(table => table.isSelectable && !omit(table, \"filter\"))\n      .filter(table => !!table.namespace)\n      .forEach(table => {\n        const tableTypeName = inflection.tableType(table);\n        /* const TableConditionType = */\n        newWithHooks(\n          GraphQLInputObjectType,\n          {\n            description: `A condition to be used against \\`${tableTypeName}\\` object types. All fields are tested for equality and combined with a logical ‘and.’`,\n            name: inflection.conditionType(inflection.tableType(table)),\n            fields: context => {\n              const { fieldWithHooks } = context;\n              return introspectionResultsByKind.attribute\n                .filter(attr => attr.classId === table.id)\n                .filter(attr => pgColumnFilter(attr, build, context))\n                .filter(attr => !omit(attr, \"filter\"))\n                .reduce((memo, attr) => {\n                  const fieldName = inflection.column(attr);\n                  memo = build.extend(\n                    memo,\n                    {\n                      [fieldName]: fieldWithHooks(\n                        fieldName,\n                        {\n                          description: `Checks for equality with the object’s \\`${fieldName}\\` field.`,\n                          type:\n                            pgGetGqlInputTypeByTypeIdAndModifier(\n                              attr.typeId,\n                              attr.typeModifier\n                            ) || GraphQLString,\n                        },\n                        {\n                          isPgConnectionConditionInputField: true,\n                        }\n                      ),\n                    },\n                    `Adding condition argument for ${describePgEntity(attr)}`\n                  );\n                  return memo;\n                }, {});\n            },\n          },\n          {\n            __origin: `Adding condition type for ${describePgEntity(\n              table\n            )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n              table,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            pgIntrospection: table,\n            isPgCondition: true,\n          }\n        );\n      });\n    return _;\n  });\n  builder.hook(\n    \"GraphQLObjectType:fields:field:args\",\n    (args, build, context) => {\n      const {\n        pgSql: sql,\n        gql2pg,\n        extend,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgColumnFilter,\n        inflection,\n        pgOmit: omit,\n      } = build;\n      const {\n        scope: {\n          isPgFieldConnection,\n          isPgFieldSimpleCollection,\n          pgFieldIntrospection: table,\n        },\n        addArgDataGenerator,\n        Self,\n        field,\n      } = context;\n      const shouldAddCondition =\n        isPgFieldConnection || isPgFieldSimpleCollection;\n      if (\n        !shouldAddCondition ||\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace ||\n        omit(table, \"filter\")\n      ) {\n        return args;\n      }\n      const TableType = pgGetGqlTypeByTypeIdAndModifier(table.type.id, null);\n      const TableConditionType = getTypeByName(\n        inflection.conditionType(TableType.name)\n      );\n\n      const relevantAttributes = introspectionResultsByKind.attribute\n        .filter(attr => attr.classId === table.id)\n        .filter(attr => pgColumnFilter(attr, build, context))\n        .filter(attr => !omit(attr, \"filter\"));\n\n      addArgDataGenerator(function connectionCondition({ condition }) {\n        return {\n          pgQuery: queryBuilder => {\n            if (condition != null) {\n              relevantAttributes.forEach(attr => {\n                const fieldName = inflection.column(attr);\n                const val = condition[fieldName];\n                if (val != null) {\n                  queryBuilder.where(\n                    sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                      attr.name\n                    )} = ${gql2pg(val, attr.type, attr.typeModifier)}`\n                  );\n                } else if (val === null) {\n                  queryBuilder.where(\n                    sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                      attr.name\n                    )} IS NULL`\n                  );\n                }\n              });\n            }\n          },\n        };\n      });\n\n      return extend(\n        args,\n        {\n          condition: {\n            description:\n              \"A condition to be used in determining which values should be returned by the collection.\",\n            type: TableConditionType,\n          },\n        },\n        `Adding condition to connection field '${field.name}' of '${Self.name}'`\n      );\n    }\n  );\n}: Plugin);\n"]}