{"version":3,"sources":["../../src/plugins/PgRowNode.js"],"names":["base64Decode","str","Buffer","from","String","toString","debugSql","PgRowNode","builder","hook","object","build","context","addNodeFetcherForTypeName","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","gql2pg","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","scope","isPgRowType","pgIntrospection","table","namespace","sqlFullTableName","identifier","name","attributes","attribute","filter","attr","classId","id","primaryKeyConstraint","constraint","con","type","primaryKeys","keyAttributeNums","map","num","data","identifiers","pgClient","parsedResolveInfoFragment","ReturnType","resolveData","length","Error","query","undefined","queryBuilder","forEach","key","idx","where","fragment","getTableAlias","typeModifier","text","values","compile","enabled","rows","row","fields","nodeIdFieldName","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","getNodeType","graphql","GraphQLNonNull","GraphQLID","inflection","describePgEntity","sqlCommentByAddingTags","isRootQuery","fieldWithHooks","class","reduce","memo","TableType","fieldName","tableNode","getDataFromParsedResolveInfoFragment","description","args","resolve","parent","resolveInfo","nodeId","alias","JSON","parse","NodeTypeByAlias","e","isPgNodeQuery","pgFieldIntrospection"],"mappings":"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","file":"PgRowNode.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\n\nconst base64Decode = str => Buffer.from(String(str), \"base64\").toString(\"utf8\");\nconst debugSql = debugFactory(\"graphile-build-pg:sql\");\n\nexport default (async function PgRowNode(builder) {\n  builder.hook(\"GraphQLObjectType\", (object, build, context) => {\n    const {\n      addNodeFetcherForTypeName,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      gql2pg,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgOmit: omit,\n    } = build;\n    const {\n      scope: { isPgRowType, pgIntrospection: table },\n    } = context;\n    if (!isPgRowType || !table.namespace || omit(table, \"read\")) {\n      return object;\n    }\n    const sqlFullTableName = sql.identifier(table.namespace.name, table.name);\n    const attributes = introspectionResultsByKind.attribute.filter(\n      attr => attr.classId === table.id\n    );\n    const primaryKeyConstraint = introspectionResultsByKind.constraint\n      .filter(con => con.classId === table.id)\n      .filter(con => con.type === \"p\")[0];\n    if (!primaryKeyConstraint) {\n      return object;\n    }\n    const primaryKeys =\n      primaryKeyConstraint &&\n      primaryKeyConstraint.keyAttributeNums.map(\n        num => attributes.filter(attr => attr.num === num)[0]\n      );\n    addNodeFetcherForTypeName(\n      object.name,\n      async (\n        data,\n        identifiers,\n        { pgClient },\n        parsedResolveInfoFragment,\n        ReturnType,\n        resolveData\n      ) => {\n        if (identifiers.length !== primaryKeys.length) {\n          throw new Error(\"Invalid ID\");\n        }\n        const query = queryFromResolveData(\n          sqlFullTableName,\n          undefined,\n          resolveData,\n          {},\n          queryBuilder => {\n            primaryKeys.forEach((key, idx) => {\n              queryBuilder.where(\n                sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                  key.name\n                )} = ${gql2pg(\n                  identifiers[idx],\n                  primaryKeys[idx].type,\n                  primaryKeys[idx].typeModifier\n                )}`\n              );\n            });\n          }\n        );\n        const { text, values } = sql.compile(query);\n        if (debugSql.enabled) debugSql(text);\n        const {\n          rows: [row],\n        } = await pgClient.query(text, values);\n        return row;\n      }\n    );\n    return object;\n  });\n\n  builder.hook(\"GraphQLObjectType:fields\", (fields, build, context) => {\n    const {\n      nodeIdFieldName,\n      extend,\n      parseResolveInfo,\n      pgGetGqlTypeByTypeIdAndModifier,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      pgSql: sql,\n      gql2pg,\n      getNodeType,\n      graphql: { GraphQLNonNull, GraphQLID },\n      inflection,\n      pgQueryFromResolveData: queryFromResolveData,\n      pgOmit: omit,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const {\n      scope: { isRootQuery },\n      fieldWithHooks,\n    } = context;\n    if (!isRootQuery || !nodeIdFieldName) {\n      return fields;\n    }\n    return extend(\n      fields,\n      introspectionResultsByKind.class\n        .filter(table => !!table.namespace)\n        .filter(table => !omit(table, \"read\"))\n        .reduce((memo, table) => {\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const sqlFullTableName = sql.identifier(\n            table.namespace.name,\n            table.name\n          );\n          if (TableType) {\n            const attributes = introspectionResultsByKind.attribute.filter(\n              attr => attr.classId === table.id\n            );\n            const primaryKeyConstraint = introspectionResultsByKind.constraint\n              .filter(con => con.classId === table.id)\n              .filter(con => con.type === \"p\")[0];\n            if (!primaryKeyConstraint) {\n              return memo;\n            }\n            const primaryKeys =\n              primaryKeyConstraint &&\n              primaryKeyConstraint.keyAttributeNums.map(\n                num => attributes.filter(attr => attr.num === num)[0]\n              );\n            const fieldName = inflection.tableNode(table);\n            memo = extend(\n              memo,\n              {\n                [fieldName]: fieldWithHooks(\n                  fieldName,\n                  ({ getDataFromParsedResolveInfoFragment }) => {\n                    return {\n                      description: `Reads a single \\`${\n                        TableType.name\n                      }\\` using its globally unique \\`ID\\`.`,\n                      type: TableType,\n                      args: {\n                        [nodeIdFieldName]: {\n                          description: `The globally unique \\`ID\\` to be used in selecting a single \\`${\n                            TableType.name\n                          }\\`.`,\n                          type: new GraphQLNonNull(GraphQLID),\n                        },\n                      },\n                      async resolve(parent, args, { pgClient }, resolveInfo) {\n                        const nodeId = args[nodeIdFieldName];\n                        try {\n                          const [alias, ...identifiers] = JSON.parse(\n                            base64Decode(nodeId)\n                          );\n                          const NodeTypeByAlias = getNodeType(alias);\n                          if (NodeTypeByAlias !== TableType) {\n                            throw new Error(\"Mismatched type\");\n                          }\n                          if (identifiers.length !== primaryKeys.length) {\n                            throw new Error(\"Invalid ID\");\n                          }\n\n                          const parsedResolveInfoFragment = parseResolveInfo(\n                            resolveInfo\n                          );\n                          const resolveData = getDataFromParsedResolveInfoFragment(\n                            parsedResolveInfoFragment,\n                            TableType\n                          );\n                          const query = queryFromResolveData(\n                            sqlFullTableName,\n                            undefined,\n                            resolveData,\n                            {},\n                            queryBuilder => {\n                              primaryKeys.forEach((key, idx) => {\n                                queryBuilder.where(\n                                  sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                    key.name\n                                  )} = ${gql2pg(\n                                    identifiers[idx],\n                                    primaryKeys[idx].type,\n                                    primaryKeys[idx].typeModifier\n                                  )}`\n                                );\n                              });\n                            }\n                          );\n                          const { text, values } = sql.compile(query);\n                          if (debugSql.enabled) debugSql(text);\n                          const {\n                            rows: [row],\n                          } = await pgClient.query(text, values);\n                          return row;\n                        } catch (e) {\n                          return null;\n                        }\n                      },\n                    };\n                  },\n                  {\n                    isPgNodeQuery: true,\n                    pgFieldIntrospection: table,\n                  }\n                ),\n              },\n              `Adding row by globally unique identifier field for ${describePgEntity(\n                table\n              )}. You can rename this table via:\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                { name: \"newNameHere\" }\n              )}`\n            );\n          }\n          return memo;\n        }, {}),\n      `Adding \"row by node ID\" fields to root Query type`\n    );\n  });\n}: Plugin);\n"]}