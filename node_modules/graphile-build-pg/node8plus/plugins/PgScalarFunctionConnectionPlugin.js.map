{"version":3,"sources":["../../src/plugins/PgScalarFunctionConnectionPlugin.js"],"names":["base64","str","Buffer","from","String","toString","PgScalarFunctionConnectionPlugin","builder","pgForbidSetofFunctionsToReturnNull","hook","_","build","newWithHooks","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLList","GraphQLString","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","nullableIf","condition","Type","Cursor","procedure","filter","proc","returnsSet","namespace","forEach","returnType","typeById","returnTypeId","returnTypeTable","classById","classId","NodeType","id","EdgeType","name","scalarFunctionEdge","description","fields","fieldWithHooks","cursor","addDataGenerator","usesCursor","type","resolve","data","JSON","stringify","__cursor","isCursorField","node","value","__origin","isEdgeType","nodeType","pgIntrospection","scalarFunctionConnection","recurseDataGeneratorsForField","nodes","map","entry","edges","isConnectionType","edgeType"],"mappings":"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","file":"PgScalarFunctionConnectionPlugin.js","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nexport default (function PgScalarFunctionConnectionPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false }\n) {\n  builder.hook(\"init\", (_, build) => {\n    const {\n      newWithHooks,\n      pgIntrospectionResultsByKind: introspectionResultsByKind,\n      getTypeByName,\n      pgGetGqlTypeByTypeIdAndModifier,\n      graphql: {\n        GraphQLObjectType,\n        GraphQLNonNull,\n        GraphQLList,\n        GraphQLString,\n      },\n      inflection,\n      pgOmit: omit,\n      describePgEntity,\n      sqlCommentByAddingTags,\n    } = build;\n    const nullableIf = (condition, Type) =>\n      condition ? Type : new GraphQLNonNull(Type);\n    const Cursor = getTypeByName(\"Cursor\");\n    introspectionResultsByKind.procedure\n      .filter(proc => proc.returnsSet)\n      .filter(proc => !!proc.namespace)\n      .filter(proc => !omit(proc, \"execute\"))\n      .forEach(proc => {\n        const returnType =\n          introspectionResultsByKind.typeById[proc.returnTypeId];\n        const returnTypeTable =\n          introspectionResultsByKind.classById[returnType.classId];\n        if (returnTypeTable) {\n          // Just use the standard table connection from PgTablesPlugin\n          return;\n        }\n        // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod\n        // on function arguments and return types, however maybe a later\n        // version of PG will?\n        const NodeType =\n          pgGetGqlTypeByTypeIdAndModifier(returnType.id, null) || GraphQLString;\n        const EdgeType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.scalarFunctionEdge(proc),\n            description: `A \\`${NodeType.name}\\` edge in the connection.`,\n            fields: ({ fieldWithHooks }) => {\n              return {\n                cursor: fieldWithHooks(\n                  \"cursor\",\n                  ({ addDataGenerator }) => {\n                    addDataGenerator(() => ({\n                      usesCursor: [true],\n                    }));\n                    return {\n                      description: \"A cursor for use in pagination.\",\n                      type: Cursor,\n                      resolve(data) {\n                        return base64(JSON.stringify(data.__cursor));\n                      },\n                    };\n                  },\n                  {\n                    isCursorField: true,\n                  }\n                ),\n                node: {\n                  description: `The \\`${\n                    NodeType.name\n                  }\\` at the end of the edge.`,\n                  type: NodeType,\n                  resolve(data) {\n                    return data.value;\n                  },\n                },\n              };\n            },\n          },\n          {\n            __origin: `Adding function result edge type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via:\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isEdgeType: true,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n        /*const ConnectionType = */\n        newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.scalarFunctionConnection(proc),\n            description: `A connection to a list of \\`${\n              NodeType.name\n            }\\` values.`,\n            fields: ({ recurseDataGeneratorsForField }) => {\n              recurseDataGeneratorsForField(\"edges\");\n              recurseDataGeneratorsForField(\"nodes\");\n              return {\n                nodes: {\n                  description: `A list of \\`${NodeType.name}\\` objects.`,\n                  type: new GraphQLNonNull(\n                    new GraphQLList(\n                      nullableIf(!pgForbidSetofFunctionsToReturnNull, NodeType)\n                    )\n                  ),\n                  resolve(data) {\n                    return data.data.map(entry => entry.value);\n                  },\n                },\n                edges: {\n                  description: `A list of edges which contains the \\`${\n                    NodeType.name\n                  }\\` and cursor to aid in pagination.`,\n                  type: new GraphQLNonNull(\n                    new GraphQLList(new GraphQLNonNull(EdgeType))\n                  ),\n                  resolve(data) {\n                    return data.data;\n                  },\n                },\n              };\n            },\n          },\n          {\n            __origin: `Adding function connection type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via:\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isConnectionType: true,\n            edgeType: EdgeType,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n      });\n    return _;\n  });\n}: Plugin);\n"]}