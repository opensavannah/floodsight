"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pg_1 = require("pg");
const pg_connection_string_1 = require("pg-connection-string");
const events_1 = require("events");
const postgraphile_core_1 = require("postgraphile-core");
const createPostGraphileHttpRequestHandler_1 = require("./http/createPostGraphileHttpRequestHandler");
const exportPostGraphileSchema_1 = require("./schema/exportPostGraphileSchema");
const pluginHook_1 = require("./pluginHook");
/**
 * Creates a PostGraphile Http request handler by first introspecting the
 * database to get a GraphQL schema, and then using that to create the Http
 * request handler.
 */
function getPostgraphileSchemaBuilder(pgPool, schema, incomingOptions) {
    const pluginHook = pluginHook_1.pluginHookFromOptions(incomingOptions);
    const options = pluginHook('postgraphile:options', incomingOptions, {
        pgPool,
        schema,
    });
    // Check for a jwtSecret without a jwtPgTypeIdentifier
    // a secret without a token identifier prevents JWT creation
    if (options.jwtSecret && !options.jwtPgTypeIdentifier) {
        // tslint:disable-next-line no-console
        console.warn('WARNING: jwtSecret provided, however jwtPgTypeIdentifier (token identifier) not provided.');
    }
    if (options.handleErrors && (options.extendedErrors || options.showErrorStack)) {
        throw new Error(`You cannot combine 'handleErrors' with the other error options`);
    }
    // Creates the Postgres schemas array.
    const pgSchemas = Array.isArray(schema) ? schema : [schema];
    const _emitter = new events_1.EventEmitter();
    // Creates a promise which will resolve to a GraphQL schema. Connects a
    // client from our pool to introspect the database.
    //
    // This is not a constant because when we are in watch mode, we want to swap
    // out the `gqlSchema`.
    let gqlSchema;
    const gqlSchemaPromise = createGqlSchema();
    return {
        _emitter,
        getGraphQLSchema: () => Promise.resolve(gqlSchema || gqlSchemaPromise),
        options,
    };
    async function createGqlSchema() {
        try {
            if (options.watchPg) {
                await postgraphile_core_1.watchPostGraphileSchema(pgPool, pgSchemas, options, newSchema => {
                    gqlSchema = newSchema;
                    _emitter.emit('schemas:changed');
                    exportGqlSchema(gqlSchema);
                });
                if (!gqlSchema) {
                    throw new Error("Consistency error: watchPostGraphileSchema promises to call the callback before the promise resolves; but this hasn't happened");
                }
            }
            else {
                gqlSchema = await postgraphile_core_1.createPostGraphileSchema(pgPool, pgSchemas, options);
                exportGqlSchema(gqlSchema);
            }
            return gqlSchema;
        }
        catch (error) {
            // If we fail to build our schema, log the error and exit the process.
            return handleFatalError(error);
        }
    }
    async function exportGqlSchema(newGqlSchema) {
        try {
            await exportPostGraphileSchema_1.default(newGqlSchema, options);
        }
        catch (error) {
            // If we fail to export our schema, log the error and exit the process.
            handleFatalError(error);
        }
    }
}
exports.getPostgraphileSchemaBuilder = getPostgraphileSchemaBuilder;
function postgraphile(poolOrConfig, schemaOrOptions, maybeOptions) {
    let schema;
    // These are the raw options we're passed in; getPostgraphileSchemaBuilder
    // must process them with `pluginHook` before we can rely on them.
    let incomingOptions;
    // If the second argument is undefined, use defaults for both `schema` and
    // `incomingOptions`.
    if (typeof schemaOrOptions === 'undefined') {
        schema = 'public';
        incomingOptions = {};
    }
    // If the second argument is a string or array, it is the schemas so set the
    // `schema` value and try to use the third argument (or a default) for
    // `incomingOptions`.
    else if (typeof schemaOrOptions === 'string' || Array.isArray(schemaOrOptions)) {
        schema = schemaOrOptions;
        incomingOptions = maybeOptions || {};
    }
    // Otherwise the second argument is the incomingOptions so set `schema` to the
    // default and `incomingOptions` to the second argument.
    else {
        schema = 'public';
        incomingOptions = schemaOrOptions;
    }
    // Do some things with `poolOrConfig` so that in the end, we actually get a
    // Postgres pool.
    const pgPool = 
    // If it is already a `Pool`, just use it.
    poolOrConfig instanceof pg_1.Pool || quacksLikePgPool(poolOrConfig)
        ? poolOrConfig
        : new pg_1.Pool(typeof poolOrConfig === 'string'
            ? // Otherwise if it is a string, let us parse it to get a config to
                // create a `Pool`.
                pg_connection_string_1.parse(poolOrConfig)
            : // Finally, it must just be a config itself. If it is undefined, we
                // will just use an empty config and let the defaults take over.
                poolOrConfig || {});
    const { getGraphQLSchema, options, _emitter } = getPostgraphileSchemaBuilder(pgPool, schema, incomingOptions);
    return createPostGraphileHttpRequestHandler_1.default(Object.assign({}, options, { getGqlSchema: getGraphQLSchema, pgPool,
        _emitter }));
}
exports.default = postgraphile;
function handleFatalError(error) {
    process.stderr.write(`${error.stack}\n`); // console.error fails under the tests
    process.exit(1);
    // `process.exit` will mean all code below it will never get called.
    // However, we need to return a value with type `never` here for
    // TypeScript.
    return null;
}
function constructorName(obj) {
    return ((obj &&
        typeof obj.constructor === 'function' &&
        obj.constructor.name &&
        String(obj.constructor.name)) ||
        null);
}
// tslint:disable-next-line no-any
function quacksLikePgPool(pgConfig) {
    // A diagnosis of exclusion
    if (!pgConfig || typeof pgConfig !== 'object')
        return false;
    if (constructorName(pgConfig) !== 'Pool' && constructorName(pgConfig) !== 'BoundPool')
        return false;
    if (!pgConfig['Client'])
        return false;
    if (!pgConfig['options'])
        return false;
    if (typeof pgConfig['connect'] !== 'function')
        return false;
    if (typeof pgConfig['end'] !== 'function')
        return false;
    if (typeof pgConfig['query'] !== 'function')
        return false;
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zdGdyYXBoaWxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Bvc3RncmFwaGlsZS9wb3N0Z3JhcGhpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQkFBc0M7QUFDdEMsK0RBQXdFO0FBRXhFLG1DQUFzQztBQUN0Qyx5REFBc0Y7QUFDdEYsc0dBQStGO0FBQy9GLGdGQUF5RTtBQUN6RSw2Q0FBcUQ7QUFTckQ7Ozs7R0FJRztBQUNILHNDQUNFLE1BQVksRUFDWixNQUE4QixFQUM5QixlQUFvQztJQUVwQyxNQUFNLFVBQVUsR0FBRyxrQ0FBcUIsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUMxRCxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsc0JBQXNCLEVBQUUsZUFBZSxFQUFFO1FBQ2xFLE1BQU07UUFDTixNQUFNO0tBQ1AsQ0FBQyxDQUFDO0lBQ0gsc0RBQXNEO0lBQ3RELDREQUE0RDtJQUM1RCxJQUFJLE9BQU8sQ0FBQyxTQUFTLElBQUksQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEVBQUU7UUFDckQsc0NBQXNDO1FBQ3RDLE9BQU8sQ0FBQyxJQUFJLENBQ1YsMkZBQTJGLENBQzVGLENBQUM7S0FDSDtJQUVELElBQUksT0FBTyxDQUFDLFlBQVksSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFO1FBQzlFLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztLQUNuRjtJQUVELHNDQUFzQztJQUN0QyxNQUFNLFNBQVMsR0FBa0IsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTNFLE1BQU0sUUFBUSxHQUFHLElBQUkscUJBQVksRUFBRSxDQUFDO0lBRXBDLHVFQUF1RTtJQUN2RSxtREFBbUQ7SUFDbkQsRUFBRTtJQUNGLDRFQUE0RTtJQUM1RSx1QkFBdUI7SUFDdkIsSUFBSSxTQUF3QixDQUFDO0lBQzdCLE1BQU0sZ0JBQWdCLEdBQTJCLGVBQWUsRUFBRSxDQUFDO0lBRW5FLE9BQU87UUFDTCxRQUFRO1FBQ1IsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLElBQUksZ0JBQWdCLENBQUM7UUFDdEUsT0FBTztLQUNSLENBQUM7SUFFRixLQUFLO1FBQ0gsSUFBSTtZQUNGLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtnQkFDbkIsTUFBTSwyQ0FBdUIsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsRUFBRTtvQkFDcEUsU0FBUyxHQUFHLFNBQVMsQ0FBQztvQkFDdEIsUUFBUSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO29CQUNqQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQzdCLENBQUMsQ0FBQyxDQUFDO2dCQUNILElBQUksQ0FBQyxTQUFTLEVBQUU7b0JBQ2QsTUFBTSxJQUFJLEtBQUssQ0FDYixnSUFBZ0ksQ0FDakksQ0FBQztpQkFDSDthQUNGO2lCQUFNO2dCQUNMLFNBQVMsR0FBRyxNQUFNLDRDQUF3QixDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ3ZFLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUM1QjtZQUNELE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQUMsT0FBTyxLQUFLLEVBQUU7WUFDZCxzRUFBc0U7WUFDdEUsT0FBTyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNoQztJQUNILENBQUM7SUFFRCxLQUFLLDBCQUEwQixZQUEyQjtRQUN4RCxJQUFJO1lBQ0YsTUFBTSxrQ0FBd0IsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDdkQ7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNkLHVFQUF1RTtZQUN2RSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN6QjtJQUNILENBQUM7QUFDSCxDQUFDO0FBMUVELG9FQTBFQztBQVVELHNCQUNFLFlBQXlDLEVBQ3pDLGVBQThELEVBQzlELFlBQWtDO0lBRWxDLElBQUksTUFBOEIsQ0FBQztJQUNuQywwRUFBMEU7SUFDMUUsa0VBQWtFO0lBQ2xFLElBQUksZUFBb0MsQ0FBQztJQUV6QywwRUFBMEU7SUFDMUUscUJBQXFCO0lBQ3JCLElBQUksT0FBTyxlQUFlLEtBQUssV0FBVyxFQUFFO1FBQzFDLE1BQU0sR0FBRyxRQUFRLENBQUM7UUFDbEIsZUFBZSxHQUFHLEVBQUUsQ0FBQztLQUN0QjtJQUNELDRFQUE0RTtJQUM1RSxzRUFBc0U7SUFDdEUscUJBQXFCO1NBQ2hCLElBQUksT0FBTyxlQUFlLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLEVBQUU7UUFDOUUsTUFBTSxHQUFHLGVBQWUsQ0FBQztRQUN6QixlQUFlLEdBQUcsWUFBWSxJQUFJLEVBQUUsQ0FBQztLQUN0QztJQUNELDhFQUE4RTtJQUM5RSx3REFBd0Q7U0FDbkQ7UUFDSCxNQUFNLEdBQUcsUUFBUSxDQUFDO1FBQ2xCLGVBQWUsR0FBRyxlQUFlLENBQUM7S0FDbkM7SUFFRCwyRUFBMkU7SUFDM0UsaUJBQWlCO0lBQ2pCLE1BQU0sTUFBTTtJQUNWLDBDQUEwQztJQUMxQyxZQUFZLFlBQVksU0FBSSxJQUFJLGdCQUFnQixDQUFDLFlBQVksQ0FBQztRQUM1RCxDQUFDLENBQUUsWUFBcUI7UUFDeEIsQ0FBQyxDQUFDLElBQUksU0FBSSxDQUNOLE9BQU8sWUFBWSxLQUFLLFFBQVE7WUFDOUIsQ0FBQyxDQUFDLGtFQUFrRTtnQkFDbEUsbUJBQW1CO2dCQUNuQiw0QkFBdUIsQ0FBQyxZQUFZLENBQUM7WUFDdkMsQ0FBQyxDQUFDLG1FQUFtRTtnQkFDbkUsZ0VBQWdFO2dCQUNoRSxZQUFZLElBQUksRUFBRSxDQUN2QixDQUFDO0lBRVIsTUFBTSxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsR0FBRyw0QkFBNEIsQ0FDMUUsTUFBTSxFQUNOLE1BQU0sRUFDTixlQUFlLENBQ2hCLENBQUM7SUFDRixPQUFPLDhDQUFvQyxtQkFDdEMsT0FBTyxJQUNWLFlBQVksRUFBRSxnQkFBZ0IsRUFDOUIsTUFBTTtRQUNOLFFBQVEsSUFDUixDQUFDO0FBQ0wsQ0FBQztBQXpERCwrQkF5REM7QUFFRCwwQkFBMEIsS0FBWTtJQUNwQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsc0NBQXNDO0lBQ2hGLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFaEIsb0VBQW9FO0lBQ3BFLGdFQUFnRTtJQUNoRSxjQUFjO0lBQ2QsT0FBTyxJQUFhLENBQUM7QUFDdkIsQ0FBQztBQUVELHlCQUF5QixHQUFVO0lBQ2pDLE9BQU8sQ0FDTCxDQUFDLEdBQUc7UUFDRixPQUFPLEdBQUcsQ0FBQyxXQUFXLEtBQUssVUFBVTtRQUNyQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUk7UUFDcEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUNMLENBQUM7QUFDSixDQUFDO0FBRUQsa0NBQWtDO0FBQ2xDLDBCQUEwQixRQUFhO0lBQ3JDLDJCQUEyQjtJQUMzQixJQUFJLENBQUMsUUFBUSxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVE7UUFBRSxPQUFPLEtBQUssQ0FBQztJQUM1RCxJQUFJLGVBQWUsQ0FBQyxRQUFRLENBQUMsS0FBSyxNQUFNLElBQUksZUFBZSxDQUFDLFFBQVEsQ0FBQyxLQUFLLFdBQVc7UUFDbkYsT0FBTyxLQUFLLENBQUM7SUFDZixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ3RDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFDdkMsSUFBSSxPQUFPLFFBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxVQUFVO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFDNUQsSUFBSSxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxVQUFVO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFDeEQsSUFBSSxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxVQUFVO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFDMUQsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIn0=